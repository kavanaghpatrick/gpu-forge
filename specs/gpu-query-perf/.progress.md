# Progress: gpu-query-perf

## Original Goal

Fix 5 critical performance bottlenecks in gpu-query that cause a 1M-row compound filter GROUP BY query to take 367ms instead of <50ms target. Bottlenecks: (1) Double CSV scan in GpuCompoundFilter, (2) QueryExecutor recreated per query, (3) CPU-side VARCHAR dictionary rebuild, (4) Schema re-inference every query, (5) Catalog re-scan every query. Three caching layers fix all five: per-query ScanCache, persistent QueryExecutor in AppState, CatalogCache with mtime+size fingerprinting. Target: warm queries <50ms.

## Reality Check (BEFORE)

**Goal type**: Fix
**Reproduction command**: `cd gpu-query && cargo test --lib`
**Exit code**: 0
**Error output**:
```
test result: ok. 494 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.11s
```

**Key issues to resolve** (performance, not test failures):
- B1: Double CSV scan in compound filters at executor.rs:379-395 (~120-150ms waste)
- B2: QueryExecutor recreated per query at ui.rs:375 / event.rs:216 (~10-25ms)
- B3: CPU VARCHAR dictionary rebuild at executor.rs:3109-3182 (~40-80ms)
- B4: Schema re-inference every query at executor.rs:3020-3028 (~2-5ms)
- B5: Catalog re-scan every query at ui.rs:345 / event.rs:215 (~1-3ms)

**Baseline**: 367ms for 1M-row compound filter GROUP BY query
**Target**: <50ms warm query

## Current Phase
tasks

## Completed Tasks
- [x] 1.1 Add scan_cache field to QueryExecutor
- [x] 1.2 Add ensure_scan_cached and execute_scan_uncached methods

## Current Task
Awaiting next task

## Learnings
- QueryExecutor is a clean 2-field struct (GpuDevice + PsoCache) at executor.rs:254-257 -- trivial to add scan_cache HashMap
- resolve_input returns owned (ScanResult, Option<FilterResult>) -- must refactor to return String key for cache pattern
- AppState is a flat pub-field struct with 20 fields and simple new() constructor -- straightforward extension point
- scan_directory is called from 3 TUI locations: mod.rs:65, ui.rs:345, event.rs:215 -- all must be replaced
- QueryExecutor::new is called from 2 TUI locations: ui.rs:375, event.rs:216 -- both need persistent executor
- ScanResult already contains mmap + ColumnarBatch + RuntimeSchema -- no new wrapper needed for cache value
- build_csv_dictionaries stores dictionaries in ColumnarBatch.dictionaries -- cached with scan result automatically
- PsoCache in pipeline.rs uses HashMap with composite key -- ScanCache follows same pattern
- No async runtime exists; keeping synchronous is the right call for <50ms target
- Foreman analysis is exceptionally thorough (1073-line TECH.md) -- trust the architecture, execute faithfully
- scan_cache field added with dead_code warning (expected -- used in task 1.2)
- Borrow checker concern: executor.take()/put-back pattern needed when both executor and app.set_result() need &mut app
- CLI path (cli/mod.rs:254) stays per-invocation -- only TUI gets persistent state
- execute_scan had 4 callers (lines 313, 360, 372, 2689) -- all renamed to execute_scan_uncached; callers update to cache pattern in task 1.3
- ensure_scan_cached uses to_ascii_lowercase for cache key normalization -- consistent with execute_scan's eq_ignore_ascii_case lookup
- ensure_scan_cached needs &mut self (cache insert) while execute_scan_uncached stays &self -- borrow split works cleanly
