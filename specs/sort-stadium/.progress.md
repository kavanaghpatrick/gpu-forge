# Sort Stadium Progress

## Original Goal
Real-time GPU radix sort visualization demo. 16M elements as fullscreen heatmap texture, showcasing 4861 Mkeys/s exp17 hybrid sort and 3009 Mkeys/s exp16 8-bit sort. Interactive controls, CPU comparison mode. New Rust project: sort-demo/ using winit + objc2-metal + CAMetalLayer.

## Plan Reference
Full architecture plan at: /Users/patrickkavanagh/.claude/plans/lively-squishing-wolf.md

## Key Context
- exp17 hybrid MSD+LSD sort: 4861 Mkeys/s @ 16M (5 dispatches, 1 encoder)
- exp16 8-bit radix sort: 3009 Mkeys/s @ 16M (10 encoders, 4 passes)
- particle-system/ has working winit + Metal rendering pipeline to reuse
- All objc2-metal, macOS ARM64

## Learnings

### Research Phase (2026-02-20)

- **build.rs: use metal-gpu-experiments/build.rs, NOT particle-system/build.rs** — particle-system lacks `-std=metal3.2` which is required by exp16_partition's `atomic_thread_fence(thread_scope_device)` and exp17's device-scope fence kernels
- **exp17 result always in buf_a** — confirmed at exp17_hybrid.rs:2017; inner 3 passes: b→a, a→b, b→a (odd = back to buf_a after MSD wrote a→b)
- **exp16 result always in buf_a** — confirmed at exp16_8bit.rs:193-194; 4 passes (even) ping-pong ends in starting buffer
- **4096×4096 ≠ 16M exactly** — 4096²=16,777,216; use bounds guard `if (gid >= N) return` in visualize kernel; extra 777K pixels show black
- **buf_msd_hist must be CPU-zeroed before each exp17 sort** — `write_bytes(..., 256*4)` before commandBuffer() creation
- **buf_global_hist must be CPU-zeroed before each exp16 sort** — `write_bytes(..., 4*256*4)` before commandBuffer() creation
- **framebufferOnly(true) is correct** — heatmap is a SEPARATE texture, not the drawable; drawable is still framebuffer-only from layer perspective
- **types.h must include FLAG_NOT_READY/FLAG_AGGREGATE/FLAG_PREFIX/FLAG_SHIFT/VALUE_MASK** — exp16_partition's decoupled lookback requires these from types.h
- **exp16 buf_tile_status at 64M = 16 MB** (not 62.5 MB) — 64M/4096 = 15,625 tiles × 256 × 4B = 16 MB
- **CPU sort time for 16M ~0.8s, not 2+ seconds** — plan overestimates; still 275x slower than GPU; use 64M mode (~3.3s CPU vs ~13ms GPU) for maximum contrast
- **StorageModeShared sufficient for heatmap texture** — .private gives bandwidth compression but heatmap write is not bandwidth-bound; keep simple
- **JoinHandle::is_finished stable since Rust 1.61.0** — project uses 1.93.0; no compatibility risk
- **BucketDesc = 4 u32 fields = 16 bytes** — for buf_bucket_descs allocation: 256 × 16 = 4096 bytes
- **buf_inner_hists = 786 KB** — 256 buckets × 3 passes × 256 bins × 4 bytes; fixed regardless of element count
- **exp17 Investigation T is exactly 5 dispatches in 1 encoder** — all within single computeCommandEncoder(); implicit device-scope barrier between dispatches
- **exp16 uses 10 encoders** — 1 hist + 1 prefix + 4 × (zero_status + partition); each encoder boundary = implicit device-scope barrier
- **texture access::write in compute kernel** — `texture2d<half, access::write>` for heatmap output; `out.write(color, uint2(x, y))` syntax
- **GPU Forge KB has no texture write findings** — standard Metal API; not in KB; pattern derived from metal_ctx.rs and Metal docs

### Requirements Phase (2026-02-20)

- **8 user stories cover full demo scope** — heatmap, instant sort, algorithm switch, CPU comparison, scaling, barchart, auto-sort, live stats
- **NFR sort targets include headroom** — <5ms exp17 / <8ms exp16 vs actual ~2.9ms / ~5.3ms; accounts for shuffle + visualize overhead in same frame
- **Bar chart column count is an unresolved question** — could be texture-width columns (4096) or fewer; needs design decision
- **CPU sort time discrepancy** — plan says 2+s, research says ~0.8s @ 16M; actual measurement needed during implementation; use 64M mode for dramatic contrast
- **Memory budget 600MB @ 64M is tight but feasible** — 2x256MB sort + 256MB texture + ~16MB tile_status + ~1MB scratch = ~529MB actual

### Design Phase (2026-02-20)

- **Heatmap texture should be StorageModePrivate** — GPU-only access gets automatic lossless bandwidth compression (KB #73); research recommended Shared but Private is better since CPU never reads the texture
- **Texture dim change requires triple-buffer drain** — if heatmap_texture is referenced by in-flight command buffers when recreating, must drain all 3 slots first (same pattern as particle-system pool grow)
- **exp17 5 kernels can share one compute encoder with sort shuffle** — shuffle (gpu_random_fill) -> sort (5 dispatches) can all be in single encoder since implicit barriers exist between dispatches within one encoder
- **Autorelease pool per frame is critical** — particle-system doesn't have one (observed), but gpu-search wraps every dispatch in autoreleasepool. For sort-demo, wrap render() body in autoreleasepool to prevent Metal object accumulation
- **exp16 Exp16Params has 5 u32 fields = 20 bytes** — different from exp17's Exp17Params (4 fields = 16 bytes); extra `num_tgs` field (redundant with num_tiles but kept for shader compat)
- **sort_exp17.metal needs both struct defs AND #define constants from original file** — kernels reference EXP17_TILE_SIZE, EXP17_ELEMS, EXP17_THREADS, EXP17_NUM_SGS, EXP17_MAX_TPB at minimum
- **sort_exp16.metal also references types.h for FLAG_* constants** — the `#include "types.h"` must be kept; types.h provides the decoupled lookback flag definitions
- **Barchart dispatch is texture_width*texture_height threads** — different from heatmap which dispatches N threads; barchart needs every pixel because each column samples one element but all rows must be computed
- **First frame shows all-black** — buf_a allocated with zeros means heatmap maps value 0 = leftmost color (near red); actually more accurate: all zeros = all same color, not gradient. User must press Space before seeing useful visualization

### Implementation Phase (2026-02-20)

- **sort-demo is standalone crate (no workspace)** — run cargo commands from sort-demo/ directory, not workspace root
- **frame.rs verbatim copy compiles with dead_code warnings** — expected since stub main.rs doesn't use FrameRing; warnings will disappear once gpu.rs and main.rs are fully wired

## Completed Tasks
- [x] 1. Create sort-demo project scaffold

## Current Task
Awaiting next task

## Next
Task 2: Create shaders - types.h, render.metal, visualize.metal

### Task Planning Phase (2026-02-20)

- **18 tasks across 5 phases** — POC (5 tasks + 1 verify), Sort Integration (4 tasks + 2 verify), Features (4 tasks + 1 verify), Polish (3 tasks + 1 verify), PR Lifecycle (2 tasks)
- **exp17 shader copy: 5 specific kernels from 2620-line file** — must extract only: exp17_msd_histogram (lines 64-119), exp17_msd_prep (lines 2287-2315), exp17_msd_atomic_scatter (lines 2186-2274), exp17_inner_precompute_hists (lines 1613-1667), exp17_inner_fused_v3 (lines 1830-1963). There are ~20 other experimental kernels in the file that must NOT be copied.
- **exp16 shader copy: 4 specific kernels from 1660-line file** — must extract only: exp16_combined_histogram (lines 303-362), exp16_global_prefix (lines 370-391), exp16_zero_status (lines 397-410), exp16_partition (lines 433-576). There are ~10 diagnostic/variant kernels that must NOT be copied.
- **exp17_msd_prep buffer(3) is `constant uint& tile_size`** — NOT a struct, just a single u32. Pass via setBytes with value 4096.
- **Task dependency chain**: scaffold -> shaders -> gpu.rs+main.rs -> vis.rs -> random_fill -> exp17_sort -> exp16_sort -> features -> polish. Each task builds incrementally on the previous.
- **POC checkpoint is Task 7** — after Space key triggers sort, the core demo is proven. Everything after is feature work.
- **Quality checkpoints after every 2-3 tasks** — inserted at tasks 5.5, 7.5, 9.5, 13.5, 15.5 to catch clippy/type issues early
- **Verify commands are all `cargo build/test/clippy`** — no manual verification needed; the demo is visual but the build proves shader compilation and Rust type correctness
