---
spec: gpu-sort-3000
basePath: specs/gpu-sort-3000
phase: requirements
task: 0/0
updated: 2026-02-19
---

# Progress: gpu-sort-3000

## Original Goal

Optimize Metal radix sort from 1909 to 3000+ Mkeys/s @ 16M elements on M4 Pro. Three GPU-only optimizations: (1) 8-bit radix with 4 passes instead of 8 (halves bandwidth, use per-SG atomic histogram instead of SIMD butterfly for 256 bins), (2) shared memory reorder before scatter (coalesce writes per digit bucket instead of random scatter), (3) larger tiles 4096+ elements (amortize lookback overhead). All changes in metal-gpu-experiments/shaders/exp16_*.metal and metal-gpu-experiments/src/exp16_*.rs. Build on proven exp15 architecture: per-SG atomic ranking, device-scope fence for cross-TG coherence, non-persistent dispatch. Current bottleneck: 53% bandwidth utilization (130 GB/s of 245 GB/s peak) due to random scatter writes and 8 passes. Target: 3000+ Mkeys/s = ~75% bandwidth efficiency with 4 passes.

## Completed Tasks

- [x] 1.1 Create exp16 Metal shader with 4 kernels (2048 tile, 256 bins, 4 passes)
- [x] 1.2 Create exp16 Rust host with bench and correctness verification

## Current Task

Awaiting next task

## Learnings

- **Initial 8-bit radix results at 2048 tile**: 1M=1806 Mkeys/s, 4M=2913 Mkeys/s, 16M=2931 Mkeys/s — all correct on first run. Already ~1.5x over exp15's ~1909 Mkeys/s at 16M. 4096 tile size in Phase 2 should push past 3000 target.
- **8-bit radix is feasible** but comes with TG memory constraints: 256-bin histogram requires 26KB of 32KB limit, blocking adoption of full shared memory reorder buffer
- **Hybrid approach recommended**: 8-bit radix + 4096 elem/tile (reduces lookback depth by 50%) + block-wise per-digit scatter instead of full reorder (saves ~4-8KB TG memory)
- **Apple Silicon write coalescing has no severe penalty** (KB #268) unlike NVIDIA/AMD, so random scatter is less painful but still suboptimal
- **Per-SG atomic ranking scales to 256 bins** without SIMD shuffles, avoiding the 4000x Metal compiler pathology observed with shuffle+TG-mem combinations
- **Register pressure at 4096 elem/tile is ~36 registers** (4K uint[16] + md[16] + mv[16] load), safe within Apple's ~100-reg limit for dual-dispatch occupancy
- **Lookback overhead dominates at 16M scale**: 7812 tiles (2048 elem/tile) vs 3906 tiles (4096 elem/tile) = 50% fewer backward lookups
- **Exp14 proven technique**: local sort into shared memory for coalesced scatter works but needs 1-16KB depending on tile size; block-wise variant (per-digit sequential write) can achieve similar coalescing with 50% less TG memory
- **Estimated speedup from 8-bit + 4K tiles**: 1.55-1.65x over exp15 = 2960-3150 Mkeys/s, achieving target
- **Bandwidth utilization remains low** (14% at 3000 Mkeys/s on M4 Pro 245 GB/s), confirming compute/latency dominates over memory

## Blockers

- None currently

## Next

Task 1.3: Debug and fix correctness at 1M elements

## Learnings (Requirements Phase)

- **Combined histogram register concern**: 256 private counters per pass would blow register budget; must use per-SG shared memory reduction (process one pass per loop iteration, reuse TG memory)
- **Tile status buffer is large**: 3906 tiles x 256 bins x 4B = 3.75 MB device memory for decoupled lookback at 8-bit radix; acceptable on M4 Pro but notable increase from exp15's 488KB
- **Block-wise scatter is medium priority**: Apple's mild uncoalesced penalty (KB #268) means random scatter may be "good enough"; block scatter adds complexity for possibly <5% gain. Worth benchmarking but not blocking.
- **Incremental optimization path is essential**: 8-bit radix alone should yield ~1.3-1.5x; add larger tiles for ~1.55-1.65x; block scatter is optional polish
- **Per-pass timing needed early**: Without per-pass breakdown, can't identify whether histogram, lookback, or scatter dominates — build timing into first iteration

## Learnings (Design Phase)

- **TG memory reuse is critical**: sg_counts (8KB) and sg_rank_ctr (8KB) have non-overlapping lifetimes (Phase 2 vs Phase 5) — sharing saves 8KB, bringing total from 26KB to 18KB with 14KB headroom
- **256-thread lookback is a major structural advantage**: exp15 used only 16 threads for lookback (240 idle); exp16 uses all 256 threads (one per bin), giving 16x more lookback parallelism
- **Per-SG atomics for histogram, not just ranking**: exp15 used private counters + SIMD butterfly for histogram (feasible at 16 bins). At 256 bins, private counters = 256 registers (spill). Must use per-SG atomic_fetch_add on TG memory for BOTH histogram and ranking phases.
- **Global prefix for 256 bins needs chunked approach**: exp15 used simd_prefix_exclusive_sum for 16 bins in one SIMD. 256 bins requires 8 serial chunks of 32, processed by one SG per pass (4 SGs for 4 passes in parallel).
- **Invalid element digit should be 0xFF**: Sorts to bin 255 (end), masked out during scatter via mv[e]. Simpler than special-casing invalid elements.
- **Half-tile reorder is the viable coalesced scatter approach**: Full 4096-element reorder (16KB) exceeds remaining TG budget. Two sub-passes of 2048 (8KB) fit within 27KB total. But Apple Silicon's mild uncoalesced penalty means this may not be worth the complexity — benchmark first.
- **Incremental Step 1 (8-bit at 2048 tile) is essential**: Isolates the 8-bit radix benefit from tile-size effects. If 8-bit alone doesn't improve, the 256-bin atomic histogram overhead may be the culprit.
- **Per-SG atomic contention is negligible at 256 bins**: 32 threads x 16 elements spread across 256 bins = 0.5 expected collisions per bin per SG. Far less contention than exp15's 16-bin ranking.
- **Tile status buffer grows 31x**: From 122KB (exp15) to 3.81MB (exp16) at 16M. Fits in M4 Pro SLC (~16-24MB) but lookback access pattern is random across tiles — may cause SLC misses for distant predecessors.

## Learnings (Task Planning Phase)

- **POC at 2048 tiles first, then upgrade to 4096**: Step 1 isolates 8-bit radix behavior from register pressure risk. If 256-bin atomics are too slow, we'll know before adding tile size complexity.
- **Debugging GPU sort correctness is non-trivial**: Task 1.3 explicitly budgets for debug. Common bugs: off-by-one in cross-SG prefix, global position formula, TG memory reuse timing.
- **Block-wise scatter is conditional (gated on 3.1 analysis)**: Task 3.2 only executes if per-pass timing shows scatter > 20% of pass time. Apple's mild uncoalesced penalty means this is likely skipped.
- **Build requires shader cache purge**: Every .metal change needs `rm -rf target/release/build/metal-gpu-experiments-*` before `cargo build --release`. build.rs tracks file changes but cargo caching can stale.
- **exp15 comparison needs both modules running**: main.rs must call both exp15::run() and exp16::run() for side-by-side comparison. May need to make exp15 functions pub.
- **20 tasks total across 5 phases**: POC (5), Feature (5), Optimize (2, conditional), Quality (3), PR Lifecycle (3+AC verification).
- **No separate test phase needed**: Correctness verification is built into run() function at each size. Adversarial tests added in Phase 2. No separate test framework for experiment binaries.
