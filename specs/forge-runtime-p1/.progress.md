## Reality Check (BEFORE)

**Goal type**: Add
**Description**: Build forge-runtime crate with ForgeContext, ForgeBuffer, Pipeline builder, Gather kernel

## Completed Tasks
- [x] 1.1 Create forge-runtime crate skeleton with ForgeContext
- [x] 1.2 Add with_context() to GpuSorter
- [x] 1.3 Add with_context() to GpuFilter

- [x] 1.4 Add from_raw_parts / into_raw_parts to SortBuffer and FilterBuffer

- [x] 1.5 Add ForgeBuffer trait and conversion functions
- [x] 1.6 POC: filter-then-sort with shared context
- [x] 1.7 POC Checkpoint â€” all 302 tests pass (forge-sort 192 + forge-filter 109 + forge-runtime 1)

## Current Task
Awaiting next task

## Learnings

- forge-sort and forge-filter both inline identical copies of `PsoCache`, `FnConstant`, `alloc_buffer`, and `init_device_and_queue` in their `metal_helpers.rs` files (~200 LOC duplicated)
- forge-primitives has canonical versions of MetalContext, PsoCache, BufferPool, but forge-sort/filter don't use them (they vendor their own copies)
- `encode_sort_pipeline()` already exists in forge-sort (lib.rs:453) taking encoder as param -- no new GPU work needed for sort pipeline integration
- GpuFilter's encode path (`encode_scan_partials`) also operates on a passed encoder
- Both `SortBuffer<T>` and `FilterBuffer<T>` have identical memory layout: Retained<MTLBuffer> + len + capacity + PhantomData
- `FilterResult<T>` holds Optional Retained<MTLBuffer> for both values and indices
- Each crate loads its own metallib via `env!()` macro set by build.rs -- PsoCache cannot be trivially shared across crate boundaries
- Retained<ProtocolObject<dyn MTLDevice>> is ARC-based, cheap to clone
- with_context() approach (taking Retained clones) is simpler than trait-based DI
- From<> conversions across crate boundaries hit orphan rules -- need free functions or feature-gated impls
- The filter count buffer must be zeroed by CPU before encoding dispatches (write_bytes to StorageModeShared)
- Gather kernel is trivial (~20 LOC Metal) but needs its own build.rs for metallib compilation
- ForgeContext follows same pattern as forge-primitives MetalContext but without library loading (runtime doesn't need its own shaders for context)
- GpuFilter::with_context() follows identical pattern to GpuSorter: new() delegates to with_context(device, queue), all 100 tests + 9 doc-tests pass

- from_raw_parts/into_raw_parts are simple struct construction/destructuring -- no unsafe needed
- FilterResult::take_values_buffer and take_indices_buffer consume self to transfer ownership of Retained<MTLBuffer>

- ForgeBuffer<T> trait with default is_empty() works cleanly; impl delegates to inherent methods on SortBuffer/FilterBuffer
- Conversion functions use T: SortKey + FilterKey bound -- all 6 numeric types satisfy both traits
- POC filter->sort works: ForgeContext shares device/queue, filter_result_to_sort_buffer provides zero-copy hand-off, each primitive still uses own CB
- LCG RNG (seed=42, multiply+add) produces deterministic test data with good distribution across u32 range
- POC checkpoint: Phase 1 complete. All 302 tests pass across 3 crates with zero code changes needed at checkpoint

## Next
Task 2.1 Create GPU Gather kernel and build.rs
