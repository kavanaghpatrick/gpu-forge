## Reality Check (BEFORE)

**Goal type**: Add
**Description**: Build forge-runtime crate with ForgeContext, ForgeBuffer, Pipeline builder, Gather kernel

## Learnings

- forge-sort and forge-filter both inline identical copies of `PsoCache`, `FnConstant`, `alloc_buffer`, and `init_device_and_queue` in their `metal_helpers.rs` files (~200 LOC duplicated)
- forge-primitives has canonical versions of MetalContext, PsoCache, BufferPool, but forge-sort/filter don't use them (they vendor their own copies)
- `encode_sort_pipeline()` already exists in forge-sort (lib.rs:453) taking encoder as param -- no new GPU work needed for sort pipeline integration
- GpuFilter's encode path (`encode_scan_partials`) also operates on a passed encoder
- Both `SortBuffer<T>` and `FilterBuffer<T>` have identical memory layout: Retained<MTLBuffer> + len + capacity + PhantomData
- `FilterResult<T>` holds Optional Retained<MTLBuffer> for both values and indices
- Each crate loads its own metallib via `env!()` macro set by build.rs -- PsoCache cannot be trivially shared across crate boundaries
- Retained<ProtocolObject<dyn MTLDevice>> is ARC-based, cheap to clone
- with_context() approach (taking Retained clones) is simpler than trait-based DI
- From<> conversions across crate boundaries hit orphan rules -- need free functions or feature-gated impls
- The filter count buffer must be zeroed by CPU before encoding dispatches (write_bytes to StorageModeShared)
- Gather kernel is trivial (~20 LOC Metal) but needs its own build.rs for metallib compilation
