## Reality Check (BEFORE)

**Goal type**: Add
**Description**: Build forge-runtime crate with ForgeContext, ForgeBuffer, Pipeline builder, Gather kernel

## Completed Tasks
- [x] 1.1 Create forge-runtime crate skeleton with ForgeContext
- [x] 1.2 Add with_context() to GpuSorter
- [x] 1.3 Add with_context() to GpuFilter

- [x] 1.4 Add from_raw_parts / into_raw_parts to SortBuffer and FilterBuffer

- [x] 1.5 Add ForgeBuffer trait and conversion functions
- [x] 1.6 POC: filter-then-sort with shared context
- [x] 1.7 POC Checkpoint — all 302 tests pass (forge-sort 192 + forge-filter 109 + forge-runtime 1)
- [x] 2.1 Create GPU Gather kernel and build.rs

- [x] 2.2 Add encode_sort() public method to GpuSorter
- [x] 2.3 Add encode_filter() public method to GpuFilter
- [x] 2.4 Build Pipeline struct and execute method

- [x] 3.1 Integration tests for full pipeline

## Current Task
Awaiting next task

## Learnings
- Pipeline::sort() only accepts SortBuffer<u32> (not generic) — multi-type filter->sort tests must use u32 for sort, other types tested via filter-only pipelines
- Pipeline methods take &self (not &mut self) — no mut needed on pipeline variables
- MTLBuffer trait must be imported (use objc2_metal::MTLBuffer as _) for .contents() in integration tests
- PendingFilterResult requires execute() before resolve() — filter->sort needs two pipeline instances (one for filter, one for sort after resolving count)


- forge-sort and forge-filter both inline identical copies of `PsoCache`, `FnConstant`, `alloc_buffer`, and `init_device_and_queue` in their `metal_helpers.rs` files (~200 LOC duplicated)
- forge-primitives has canonical versions of MetalContext, PsoCache, BufferPool, but forge-sort/filter don't use them (they vendor their own copies)
- `encode_sort_pipeline()` already exists in forge-sort (lib.rs:453) taking encoder as param -- no new GPU work needed for sort pipeline integration
- GpuFilter's encode path (`encode_scan_partials`) also operates on a passed encoder
- Both `SortBuffer<T>` and `FilterBuffer<T>` have identical memory layout: Retained<MTLBuffer> + len + capacity + PhantomData
- `FilterResult<T>` holds Optional Retained<MTLBuffer> for both values and indices
- Each crate loads its own metallib via `env!()` macro set by build.rs -- PsoCache cannot be trivially shared across crate boundaries
- Retained<ProtocolObject<dyn MTLDevice>> is ARC-based, cheap to clone
- with_context() approach (taking Retained clones) is simpler than trait-based DI
- From<> conversions across crate boundaries hit orphan rules -- need free functions or feature-gated impls
- The filter count buffer must be zeroed by CPU before encoding dispatches (write_bytes to StorageModeShared)
- Gather kernel is trivial (~20 LOC Metal) but needs its own build.rs for metallib compilation
- ForgeContext follows same pattern as forge-primitives MetalContext but without library loading (runtime doesn't need its own shaders for context)
- GpuFilter::with_context() follows identical pattern to GpuSorter: new() delegates to with_context(device, queue), all 100 tests + 9 doc-tests pass

- from_raw_parts/into_raw_parts are simple struct construction/destructuring -- no unsafe needed
- FilterResult::take_values_buffer and take_indices_buffer consume self to transfer ownership of Retained<MTLBuffer>

- ForgeBuffer<T> trait with default is_empty() works cleanly; impl delegates to inherent methods on SortBuffer/FilterBuffer
- Conversion functions use T: SortKey + FilterKey bound -- all 6 numeric types satisfy both traits
- POC filter->sort works: ForgeContext shares device/queue, filter_result_to_sort_buffer provides zero-copy hand-off, each primitive still uses own CB
- LCG RNG (seed=42, multiply+add) produces deterministic test data with good distribution across u32 range
- POC checkpoint: Phase 1 complete. All 302 tests pass across 3 crates with zero code changes needed at checkpoint
- MTLSize fields are `usize` (not `u64`) in objc2-metal 0.3 — use struct literal `MTLSize { width, height, depth }`
- MTLCommandBuffer, MTLCommandEncoder, MTLCommandQueue traits must be in scope (use import) for method calls on ProtocolObject
- GpuGather follows same pattern as GpuSorter/GpuFilter: new() + with_context(), env!() metallib path, PSO pre-compilation
- gather.metal kernels are ~6 LOC each: bounds check + indexed read. Indices always u32 even for u64 gather.

- encode_sort() mirrors sort_buffer() logic: ensure_scratch_buffers + zero MSD hist + encode_sort_pipeline, but skips CB/encoder creation
- alloc_sort_buffer(0) fails on Metal (0-byte buffer allocation rejected) — use capacity >= 1 in tests
- encode_sort with n<=1 returns Ok immediately without encoding any dispatches, so an empty encoder with just endEncoding+commit works fine
- encode_filter() uses PendingFilterResult with deferred count resolution — GPU count buffer is StorageModeShared, CPU reads after commit+wait
- encode_filter() encodes the bitmap pipeline (bitmap_scan → scan_partials → bitmap_scatter) identical to dispatch_filter_bitmap but without CB creation/commit
- PendingFilterResult::resolve() reads count_buf[0] as u32 and constructs FilterResult — must only call after CB completes
- For n=0 encode_filter, count_buf is allocated and zeroed so resolve() safely returns count=0

- Pipeline struct is lightweight: holds Retained<MTLCommandBuffer> + Retained<MTLComputeCommandEncoder>
- Pipeline methods take &mut references to GpuSorter/GpuFilter/GpuGather — caller retains ownership of primitives
- Pipeline::execute() consumes self (moves cmd+encoder) to prevent reuse after commit
- PendingFilterResult from pipeline.filter() must be resolved AFTER pipeline.execute() — deferred count pattern

## Next
Task 3.2 Backward compatibility tests
