---
spec: forge-sort-v2
basePath: ./specs/forge-sort-v2
phase: requirements
task: 0/0
updated: 2026-02-20
---

# Progress: forge-sort-v2

## Original Goal

Add i32, f32, u64, i64, f64, argsort, and key-value pair sorting to forge-sort GPU radix sort library. Extend Metal shaders with function constants (HAS_VALUES, IS_64BIT), GPU-side bit transforms (FloatFlip/XOR), sealed SortKey trait, generic SortBuffer<T>. 3 phases: Phase 1 (i32/f32 transforms), Phase 2 (argsort/KV with index init + gather kernels), Phase 3 (64-bit pipeline with 8 passes). Target 2800+ Mk/s for 32-bit, 800+ Mk/s for 64-bit. Full foreman spec already complete at metal-forge-compute/forge-sort/ai/tasks/spec/.

## Completed Tasks
- [x] 1.1 Extend PsoCache with function constant support
- [x] 1.2 Add SortKey sealed trait and make SortBuffer generic
- [x] 1.3 Update existing tests for SortBuffer<u32> annotation
- [x] V1 [VERIFY] Quality checkpoint: cargo check + existing tests
- [x] 1.4 Add sort_transform_32 kernel + function constant declarations to sort.metal
- [x] 1.5 Implement sort_i32 and sort_i32_buffer methods
- [x] 1.6 Implement sort_f32 and sort_f32_buffer methods
- [x] 1.7 Add i32/f32 correctness tests
- [x] V2 [VERIFY] Quality checkpoint: full test suite
- [x] 1.8 POC Checkpoint: verify i32/f32 sort end-to-end

- [x] 2.1 Add InnerParams struct and refactor sort_inner_fused binding
- [x] 2.2 Add HAS_VALUES branches to sort_msd_atomic_scatter
- [x] 2.3 Add HAS_VALUES branches to sort_inner_fused
- [x] V3 [VERIFY] Quality checkpoint: shader changes safe
- [x] 2.4 Add sort_init_indices and sort_gather_values kernels
- [x] 2.5 Implement argsort methods and lazy value buffer allocation
- [x] 2.6 Implement sort_pairs methods
- [x] 2.7 Add argsort and sort_pairs correctness tests
- [x] 3.1 Add IS_64BIT branches to sort kernels
- [x] 3.2 Add sort_transform_64 kernel
- [x] 3.3 Implement 64-bit dispatch pipeline and sort_u64 method
- [x] V5 [VERIFY] Quality checkpoint: 64-bit pipeline
- [x] 3.4 Implement sort_i64, sort_f64 and buffer variants
- [x] 3.5 Implement 64-bit argsort and sort_pairs
- [x] 3.6 Add 64-bit correctness tests
- [x] V6 [VERIFY] Quality checkpoint: complete 64-bit pipeline

## Current Task

Awaiting next task

## Learnings

- Foreman spec is comprehensive (5 files, ~5000 lines). PM/UX/TECH/QA aligned on all 13 key decisions.
- v1 has 26 tests in correctness.rs (18 integration + 3 unit + 5 buffer). All reference untyped SortBuffer.
- v1 lib.rs is 479 lines, sort.metal is 439 lines. dispatch_sort() is monolithic -- needs refactoring for SortPipelineConfig.
- sort_inner_fused currently takes bare `constant uint& batch_start [[buffer(3)]]` -- must change to InnerParams struct (breaking for kernel but we control all callers).
- PsoCache in forge-primitives has no function constant support -- must add FnConstant + get_or_create_specialized().
- i64 XOR sign-bit transform is mathematically identical to FloatFlip formula applied to two's-complement integers -- can share TRANSFORM_MODE=1 with f64 forward.
- 64-bit tile size (2048) keeps register budget at ~40/48 regs (well within M4's 96 limit).
- No build.rs changes needed: function constants resolve at PSO creation time, not shader compile time.
- Function constants with defaults (is_function_constant_defined ternary) compile cleanly in Metal -- existing kernels unaffected when constants not set. sort_transform_32 uses transform_mode function constant for mode dispatch.
- v1 SortBuffer has no PhantomData -- adding it for SortBuffer\<T\> is purely additive to the struct layout.
- sort_pairs Strategy B needs 5 n-sized buffers (320 MB @ 16M) vs Strategy A's 4 (256 MB). Extra gather dispatch is the tradeoff.
- Design phase: dispatch_sort_pipeline buffer ping-pong for 64-bit requires swapping kernel arguments (buf_a, buf_b) between dispatches, not just tracking a boolean. Inner kernel pass 0 always reads from its second buffer param.
- Design phase: PsoCache cache key format "fn_name:idx=val:idx=val" is sufficient -- no hash needed, string concatenation with constants is unique.
- Design phase: 11 eager PSOs + 7 lazy PSOs = 18 total. 64-bit lazy to avoid penalizing GpuSorter::new() startup time for users who only sort 32-bit.
- Design phase: sort.metal grows from 439 to ~560 lines. If lib.rs exceeds ~800 lines in Phase 2, consider extracting pipeline.rs and types.rs -- but defer until clearly needed.
- Option B approach for transforms: created `encode_sort_pipeline()` + `encode_transform_32()` free functions that take an encoder parameter, keeping `dispatch_sort()` untouched for u32 backward compat. i32/f32 use single cmd buffer with transform+sort+inverse_transform. `dispatchThreads_threadsPerThreadgroup` works for 1D transform kernel.
- Design phase: InnerParams struct change to sort_inner_fused is the only breaking kernel signature change. All other modifications are additive (new function constant branches, new kernels).
- PsoCache FnConstant uses string-based cache key "fn_name:idx=val" (simpler than attention-proto's PsoKey struct). Bool values serialized as 0/1 in the key string. NonNull pointer creation for setConstantValue_type_atIndex requires `&*b as *const bool as *mut c_void` pattern for borrow references.
- SortBuffer<T> generic change is fully backward-compatible: existing tests don't need changes because Rust infers T=u32 from sort_buffer(&SortBuffer<u32>) usage. All 25 integration tests + 9 unit tests pass without modifications.
- Task 1.3: No test file changes required. Type inference handles all alloc_sort_buffer calls. `cargo test -p forge-sort --release -- --test-threads=1` → 25 passed, 0 failed.
- Task 1.6: sort_f32/sort_f32_buffer identical to sort_i32 pattern but mode=1 (FloatFlip forward) and mode=2 (IFloatFlip inverse). Test verifies total_cmp ordering via to_bits() comparison for NaN/Inf/-0.0 edge cases. 36 tests pass (11 unit + 25 integration).
- Task 1.7: 12 i32 tests + 15 f32 tests added. All pass including 16M random data, IEEE 754 specials, NaN variants, denormals, buffer API. Use `assert_bits_eq` helper for f32 (NaN != NaN). rand_chacha 0.3 with ChaCha8Rng::seed_from_u64 for deterministic RNG. 63 total tests now (11 unit + 25 existing + 12 i32 + 15 f32).
- Task 2.1: InnerParams struct refactor is pure plumbing — MSL struct + Rust #[repr(C)] struct must match layout. Both dispatch_sort() and encode_sort_pipeline() need updating (two callsites). start_shift=0, pass_count=3 preserves exact current behavior. All 63 tests pass.
- Task 2.2: Adding function-constant-guarded buffer bindings to a Metal kernel forces ALL callers to use specialized PSO compilation (newFunctionWithName:constantValues:). Even if `has_values` defaults to false, Metal's validator rejects plain `get_or_create` once the kernel references a function constant. Fix: change sort_msd_atomic_scatter and sort_inner_fused PSO compilation from `get_or_create` to `get_or_create_specialized` with `HAS_VALUES=false`. Dead code elimination confirmed — no perf impact. All 63 tests pass.
- Task 2.3: sort_inner_fused value tracking requires 3 additions: (1) buffer bindings vals_a/vals_b at buffer(4)/buffer(5), (2) src_vals/dst_vals pointer swap matching key ping-pong `(pass % 2u == 0u)`, (3) value load in tile read + value scatter alongside key scatter, both guarded by `if (has_values)`. Register array `uint vals[SORT_ELEMS]` declared inside tile loop (not outside pass loop) — scoped per tile, same as keys[]. Dead code elimination confirmed for HAS_VALUES=false path — no perf impact on existing tests.
- Task 2.5: Argsort pattern: clone Retained<MTLBuffer> refs before passing to encode methods that borrow &mut self (pso_cache). encode_sort_pipeline_full() is a &mut self method that binds value buffers at index 4/5 when with_values=true. No inverse transform needed for argsort — we only read indices back, not keys. 70 total tests (18 unit + 52 integration).
- Task 2.6: sort_pairs Strategy B needs 5 buffers total (buf_a, buf_b, vals_a, vals_b, orig_vals). sort_pairs_i32/f32 DO need inverse transform (unlike argsort) because we copy sorted keys back to user. Gather dispatch uses sort_gather_values PSO at buffer(0)=sorted_indices, buffer(1)=original_vals, buffer(2)=gathered_output, buffer(3)=count.
- Task 3.5: 64-bit argsort/sort_pairs extends encode_sort_pipeline_64 with optional value buffer parameters (vals_a, vals_b, with_values bool). Uses InnerConfig struct to track value buffer ping-pong alongside key buffer ping-pong for inner fused dispatches. Values always u32 (4 bytes) even with 64-bit keys. ensure_buffers_64_with_values allocates 8-byte key buffers + 4-byte value buffers. 120 total tests pass (42 unit + 78 integration).

### Verification: V1 [VERIFY] Quality checkpoint: cargo check + existing tests
- Status: PASS
- Commands: cargo check --workspace (0), cargo test -p forge-sort --release --test-threads=1 (0)
- Results: 25 passed, 0 failed (integration + doc-tests)
- Notes: cargo check produced warnings only (unused imports/vars in forge-bench, not forge-sort). All forge-sort tests clean.

### Verification: V2 [VERIFY] Quality checkpoint: full test suite
- Status: PASS
- Commands: cargo check --workspace (0), cargo test -p forge-sort --release --test-threads=1 (0)
- Results: 63 total tests — 11 unit + 25 existing u32 + 12 i32 + 15 f32 = 63 passed, 0 failed
- Notes: All forge-sort tests pass across correctness.rs, correctness_i32.rs, correctness_f32.rs. cargo check warnings are in forge-bench only (unused imports/vars), not forge-sort.

### Verification: 1.8 POC Checkpoint: verify i32/f32 sort end-to-end
- Status: PASS
- Commands: cargo test -p forge-sort --release --test-threads=1 (0) | grep -E "test result|FAILED"
- Results: 5 "test result: ok" lines, 0 FAILED
- Notes: sort_i32 and sort_f32 produce correct results. No u32 regressions. Phase 1 complete.

### Task 2.4: Add sort_init_indices and sort_gather_values kernels
- Status: COMPLETE
- Files: forge-sort/shaders/sort.metal (+33 lines), forge-sort/src/lib.rs (+5 lines)
- sort_init_indices: 1D dispatch, fills indices[gid]=gid, buffer(0)=indices, buffer(1)=count
- sort_gather_values: 1D dispatch, gathered[gid]=original[sorted_indices[gid]], 4 buffer bindings
- Both PSOs pre-compiled eagerly at GpuSorter::new() via get_or_create (no function constants)
- New metallib built (confirmed by cargo build output). All 63 tests pass.
- Commit: feat(forge-sort): add sort_init_indices and sort_gather_values kernels

### Verification: V3 [VERIFY] Quality checkpoint: shader changes safe
- Status: PASS
- Commands: cargo check --workspace (0), cargo test -p forge-sort --release --test-threads=1 (0)
- Results: 63 total tests — 11 unit + 25 existing u32 + 15 f32 + 12 i32 = 63 passed, 0 failed
- Notes: HAS_VALUES branches in sort_msd_atomic_scatter and sort_inner_fused do not affect default path (dead code elimination confirmed). cargo check warnings in forge-bench only, not forge-sort.

### Task 2.5: Implement argsort methods and lazy value buffer allocation
- Status: COMPLETE
- Files: forge-sort/src/lib.rs (+200 lines)
- Added buf_vals_a, buf_vals_b, vals_buf_capacity fields to GpuSorter
- Added ensure_buffers_with_values() for lazy value buffer allocation
- Pre-compiled HAS_VALUES=true PSOs for scatter and inner fused at init
- Added encode_sort_pipeline_full() method with optional value tracking
- Added encode_init_indices() helper method
- Implemented argsort_u32, argsort_i32, argsort_f32 — all return Vec<u32> indices
- Edge cases: empty -> Ok(vec![]), single -> Ok(vec![0])
- 7 inline tests added (3 basic + 2 empty + 1 single + 1 f32)
- 70 total tests pass (18 unit + 25 u32 + 15 f32 + 12 i32), 0 failures

## Blockers

- None currently

### Verification: V4 [VERIFY] Quality checkpoint: full test suite after Phase 2
- Status: PASS
- Commands: cargo check --workspace (0), cargo test -p forge-sort --release --test-threads=1 (0)
- Results: 102 total tests — 24 unit + 25 u32 + 14 argsort + 15 f32 + 12 i32 + 12 sort_pairs = 102 passed, 0 failed
- Notes: cargo check warnings are in forge-bench only (unused imports/vars), not forge-sort. All test binaries pass: correctness (24), correctness (25), correctness_argsort (14), correctness_f32 (15), correctness_i32 (12), correctness_sort_pairs (12), doc-tests (0). Phase 2 complete.

### Task 2.6: Implement sort_pairs methods
- Status: COMPLETE
- Files: forge-sort/src/lib.rs (+170 lines)
- Added buf_orig_vals + orig_vals_capacity fields to GpuSorter
- Added ensure_buffers_with_values_and_orig() for lazy orig values buffer allocation
- Added encode_gather_values() helper method for gather dispatch
- Implemented sort_pairs_u32, sort_pairs_i32, sort_pairs_f32 using Strategy B (argsort + gather)
- Pipeline: memcpy keys+vals → init indices → [transform] → sort(HAS_VALUES) → [inverse_transform] → gather → memcpy back
- 6 inline tests added (3 basic + 1 length mismatch + 1 empty + 1 single)
- 76 total tests pass (24 unit + 25 u32 + 15 f32 + 12 i32), 0 failures

### Task 2.7: Add argsort and sort_pairs correctness tests
- Status: COMPLETE
- Files: tests/common/mod.rs (new), tests/correctness_argsort.rs (new), tests/correctness_sort_pairs.rs (new)
- 14 argsort tests: basic, permutation_valid, sorted_order, input_unmodified, stable, 1M, 16M, i32_basic, i32_boundaries, f32_basic, f32_nan, empty, single, all_same
- 12 sort_pairs tests: basic, multiset_preserved, stable, i32_basic, f32_basic, f32_nan_with_values, length_mismatch, 1M, 16M, empty, single, all_same
- common/mod.rs: seeded_rng, verify_permutation, verify_sorted_by_indices, verify_sorted_by_indices_f32, verify_pairs_preserved (u32/i32/f32 variants)
- 102 total tests pass (24 unit + 25 u32 + 14 argsort + 15 f32 + 12 i32 + 12 sort_pairs), 0 failures
- Note: task verify command filter `correctness_argsort correctness_sort_pairs` matches binary names not function names; use `--test correctness_argsort --test correctness_sort_pairs` instead

- [x] V4 [VERIFY] Quality checkpoint: full test suite after Phase 2

### Task 3.1: Add IS_64BIT branches to sort kernels
- Status: COMPLETE
- Files: forge-sort/shaders/sort.metal (+~160 lines), forge-sort/src/lib.rs (~4 line changes)
- Added SORT_ELEMS_64 (8) and SORT_TILE_64 (2048) defines for 64-bit half-tile sizing
- sort_msd_histogram: `if (is_64bit)` branch with ulong keys, 8 elems/thread, 2048-tile
- sort_msd_atomic_scatter: `if (is_64bit)` branch with ulong keys+dst, 8 elems/thread
- sort_inner_fused: `if (is_64bit)` branch with ulong keys, variable pass_count/start_shift, values still uint
- Critical fix: sort_msd_histogram now references IS_64BIT function constant, so ALL callers must use get_or_create_specialized with IS_64BIT=false (same pattern as task 2.2 HAS_VALUES fix)
- All 102 existing 32-bit tests pass (dead code elimination confirmed for IS_64BIT=false path)

### Task 3.2: Add sort_transform_64 kernel
- Status: COMPLETE
- Files: forge-sort/shaders/sort.metal (+34 lines)
- Added sort_transform_64 kernel at end of sort.metal (Kernel 8)
- mode 1: FloatFlip64 forward (works for both f64 and i64)
- mode 2: IFloatFlip64 inverse
- Uses ulong (64-bit) data buffer, same function constant `transform_mode`
- No PSO pre-compilation yet (deferred to task 3.3 lazy init)
- test_sort_1m passes (shader compiled and existing 32-bit path unaffected)
- Commit: feat(forge-sort): add sort_transform_64 kernel for i64/f64

### Task 3.3: Implement 64-bit dispatch pipeline and sort_u64 method
- Status: COMPLETE
- Files: forge-sort/src/lib.rs (+~150 lines)
- Added lazy 64-bit PSO compilation: ensure_64bit_psos() compiles IS_64BIT=true PSOs for histogram, scatter, inner (key-only and key-value), plus sort_transform_64 modes 1-2
- Added ensure_buffers_64() and ensure_scratch_buffers_64() for 8-byte key buffer allocation with separate capacity tracking
- Added encode_sort_pipeline_64(): 6-dispatch pipeline in 1 encoder (MSD hist + prep + scatter + 3 inner fused)
- Buffer ping-pong for 3 inner dispatches:
  - Inner #1 (bytes 4-6, 3 passes): buffer(0)=buf_a, buffer(1)=buf_b → result in buf_a
  - Inner #2 (bytes 1-3, 3 passes): buffer(0)=buf_b, buffer(1)=buf_a → result in buf_b
  - Inner #3 (byte 0, 1 pass): buffer(0)=buf_a, buffer(1)=buf_b → result in buf_a
- Added sort_u64() and sort_u64_buffer() public API methods
- 3 inline tests added (basic, empty, single)
- 105 total tests pass (27 unit + 25 u32 + 14 argsort + 15 f32 + 12 i32 + 12 sort_pairs), 0 failures

### Verification: V6 [VERIFY] Quality checkpoint: complete 64-bit pipeline
- Status: PASS
- Commands: cargo check --workspace (0), cargo test -p forge-sort --release --test-threads=1 (0)
- Results: 158 total tests — 42 unit + 25 u32 + 14 argsort + 15 f32 + 12 i32 + 12 sort_pairs + 15 f32 (correctness_f32) + 11 i64 + 12 u64 + 15 f64 = 158 passed, 0 failed
- Test binaries: correctness (42 unit), correctness (25 u32), correctness_argsort (14), correctness_f32 (15), correctness_i32 (12), correctness_sort_pairs (12), correctness_i64 (11), correctness_u64 (12), correctness_f64 (15), doc-tests (0)
- Notes: cargo check warnings in forge-bench only (unused imports/vars/dead code), not forge-sort. All 64-bit types (u64, i64, f64) verified correct. Phase 3 complete.

## Next

Phase 4: Testing + Regression + Performance (task 4.1)

## Learnings (Task Planning)

- All 25 existing v1 tests pass in --release mode (verified: `cargo test -p forge-sort --release`)
- objc2-metal 0.3.2 enables all features by default -- MTLFunctionConstantValues, MTLDataType available without extra Cargo.toml features
- gpu-query and attention-proto both have working MTLFunctionConstantValues patterns: `setConstantValue_type_atIndex` + `newFunctionWithName_constantValues_error` (reference implementations)
- forge-primitives PsoCache uses descriptor-based PSO creation with occupancy hints (maxTotalThreadsPerThreadgroup=256, threadGroupSizeIsMultipleOfThreadExecutionWidth=true) -- specialized PSO must match
- rand_chacha already in Cargo.lock from other workspace members -- just needs dev-dep in forge-sort/Cargo.toml
- Working directory for cargo commands: `/Users/patrickkavanagh/gpu_kernel/metal-forge-compute`
- 35 total tasks: 10 in Phase 1 (POC), 8 in Phase 2 (argsort/KV), 8 in Phase 3 (64-bit), 4 in Phase 4 (testing), 4 in Phase 5 (quality/PR), plus 7 [VERIFY] checkpoints
- Key dependency chain: PsoCache extension (1.1) -> SortKey+SortBuffer (1.2) -> test update (1.3) -> shader changes (1.4) -> sort methods (1.5, 1.6)
- InnerParams refactor (2.1) must happen before 64-bit pipeline (3.3) since 64-bit needs variable start_shift/pass_count
- 64-bit buffer ping-pong is highest risk area: 3 inner dispatches with alternating buf_a/buf_b arguments, must track which buffer holds final output
- Task 3.1: Adding IS_64BIT function constant to sort_msd_histogram forces ALL callers (3 sites in lib.rs) to use get_or_create_specialized with IS_64BIT=false. Same pattern as task 2.2 where HAS_VALUES broke plain get_or_create for scatter/inner. Metal validator rejects plain newFunctionWithName once kernel references any function constant.
- Task 3.1: 64-bit inner sort uses inner_params.pass_count and inner_params.start_shift for variable byte extraction — pass 0 histogram pre-computes future pass histograms only if pass_count > 1/2 (conditional on inner_params.pass_count).
- Task 3.3: 64-bit sort_msd_atomic_scatter PSOs need BOTH HAS_VALUES and IS_64BIT function constants specified (2 constants per PSO). The 32-bit PSOs only specify HAS_VALUES — unset IS_64BIT defaults to false via `is_function_constant_defined` ternary. PsoCache key uniqueness ensures no collision between "fn:0=false" and "fn:0=false:1=true".
- Task 3.3: Inner kernel buffer convention: pass 0 (even) reads buffer(1), writes buffer(0). After odd passes → buffer(0). After even passes → buffer(1). For 3 inner dispatches of 64-bit sort, must alternate which physical buffer is at index 0 vs 1 to maintain correct data flow. The 32-bit sort only has 1 inner dispatch so this was invisible before.
- Task 3.3: sort_u64_buffer needs clone of self.buf_b before &mut self borrow in encode_sort_pipeline_64 (same borrow-checker pattern as argsort methods).

### Verification: V5 [VERIFY] Quality checkpoint: 64-bit pipeline
- Status: PASS
- Commands: cargo check --workspace (0), cargo test -p forge-sort --release --test-threads=1 (0)
- Results: 105 total tests — 27 unit + 25 u32 + 14 argsort + 15 f32 + 12 i32 + 12 sort_pairs = 105 passed, 0 failed
- Notes: All tests pass. No fixes needed, no commit required.

### Task 3.4: Implement sort_i64, sort_f64 and buffer variants
- Status: COMPLETE
- Files: forge-sort/src/lib.rs (+~200 lines), forge-sort/shaders/sort.metal (+2 lines)
- Added sort_i64(), sort_f64(), sort_i64_buffer(), sort_f64_buffer() public API methods
- sort_i64 uses mode=0 (XOR sign bit, self-inverse), sort_f64 uses mode=1/2 (FloatFlip64/IFloatFlip64)
- Added mode=0 to sort_transform_64 shader (simple XOR 0x8000000000000000 for i64)
- Fixed ensure_64bit_psos() to compile mode=0 PSO as well
- **CRITICAL BUG FIX**: encode_sort_pipeline_64 inner_configs had start_shift values as BIT positions (32, 8, 0) instead of BYTE indices (4, 1, 0). The kernel formula `(start_shift + pass) * 8` expects byte indices. This caused sort_u64 to extract bits beyond the 64-bit value for inner dispatches 1 and 2 (shift=256+ instead of 32+). Fixed to (4, 1, 0). Previous sort_u64 tests happened to pass because: (a) simple test values like [MAX, 0, 1, MAX-1, 42] are distinguishable by MSD byte alone, (b) inner sorts with shift>63 produce garbage digits but the MSD scatter already placed them correctly.
- **CRITICAL BUG**: SortKey for i64 had TRANSFORM_MODE_FORWARD/INVERSE = 1 (FloatFlip64) which is WRONG for integers. FloatFlip negates negative floats' magnitude ordering but INVERTS two's complement ordering (makes -1 < -2). Fixed to mode=0 (simple XOR sign bit).
- 6 inline tests added: 3 i64 (basic/empty/single) + 3 f64 (basic/empty/single)
- 111 total tests pass (33 unit + 25 u32 + 14 argsort + 15 f32 + 12 i32 + 12 sort_pairs), 0 failures

### Task 3.6: Add 64-bit correctness tests
- Status: COMPLETE
- Files: tests/correctness_u64.rs (new, 12 tests), tests/correctness_i64.rs (new, 11 tests), tests/correctness_f64.rs (new, 15 tests)
- **CRITICAL BUG FIX**: 64-bit inner sort dispatch order was MSB-first (bytes 4-6, then 1-3, then 0) instead of LSB-first. Radix sort requires LSB-to-MSB pass order for stability: each subsequent sort pass must be for more significant digits. Fixed to byte 0 first, then bytes 1-3, then bytes 4-6. Previous inline tests (5-7 elements) passed because all elements were distinguishable by MSD byte alone, so inner sort ordering didn't matter.
- 158 total tests pass (42 unit + 25 u32 + 14 argsort + 15 f32 + 12 i32 + 12 sort_pairs + 12 u64 + 11 i64 + 15 f64), 0 failures
