# Progress: gpu-query-autonomous

## Original Goal

Build a GPU-autonomous query engine achieving sub-1ms warm query latency on 1M rows by getting the CPU out of the loop entirely. Architecture: persistent Metal compute kernel with completion-handler re-dispatch, JIT Metal shader compilation, fused filter+aggregate+GROUP BY kernel, binary columnar pre-loaded data, triple-buffered work queue, zero-readback unified memory output. New AutonomousExecutor struct. Live mode ON by default, 0ms debounce. 64-group GROUP BY limit. Separate command queue.

## Reality Check (BEFORE)

**Goal type**: Greenfield (new execution architecture alongside existing)
**Reproduction command**: `cd gpu-query && cargo test --lib`
**Baseline**: 36ms warm query latency for 1M-row compound filter + GROUP BY
**Target**: <1ms warm query latency (same workload)

## Current Phase
execution

## Completed Tasks
- Spec synthesis (research.md, requirements.md, design.md, tasks.md)
- [x] 1.1 Create autonomous module structure
- [x] 1.2 Define #[repr(C)] shared types with layout tests
- [x] 1.3 Create MSL shared type header
- [x] 1.4 Implement triple-buffered work queue
- [x] 1.5 Implement binary columnar data loader
- [x] 1.6 Foundation checkpoint - ALL TESTS PASS (901 total: 807 existing + 94 autonomous)
- [x] 2.1 Create AOT fused query Metal shader
- [x] 2.2 Add fused kernel PSO compilation to pipeline

## Current Task
Awaiting next task


## Learnings
- Full foreman spec analysis exists in ai/tasks/spec/ (PM.md 498 lines, UX.md 902 lines, TECH.md 1576 lines, QA.md 1312 lines)
- All Q&A decisions captured in each spec file
- Synthesis insight: 42 tasks across 7 phases, POC-first structure
- Existing codebase uses #[repr(C)] structs with MSL counterparts + comprehensive offset tests in types.rs -- autonomous types must follow same pattern
- PSO caching pattern exists in pipeline.rs -- JIT cache follows same HashMap pattern
- Filter.metal shows function constant specialization (COMPARE_OP, COLUMN_TYPE, HAS_NULL_CHECK) -- AOT fallback kernel follows this
- aggregate.metal has simd_sum_int64 helper via lo/hi split for 64-bit SIMD reductions -- reuse in fused kernel
- 32KB threadgroup memory limit [KB #22] constrains GROUP BY to 64 groups (10KB) for safe margin
- True persistent kernels NOT feasible on Metal [KB #151, #440, #441] -- must use bounded time-slice + completion-handler re-dispatch [KB #152]
- CPU-GPU memory ordering not well-defined [KB #154] -- Acquire-Release on sequence_id is critical
- Phase 2 deliberately uses waitUntilCompleted for one-shot dispatch to prove fused kernel correctness before persistent kernel in Phase 4
- Key technical decisions from Q&A: hard <1ms all 6 pillars, 0ms debounce, JIT+AOT, 64-group limit, completion-handler re-dispatch MVP, separate command queue, per-type binary buffers matching ColumnarBatch, split float tolerance (exact int, 1e-5 float), loom behind feature flag
- Module structure: autonomous/mod.rs re-exports types, work_queue, loader, executor, jit sub-modules
- Design says _padding is [u8; 208] but field-by-field computation shows 196B from offset 316 to reach 512B total -- use 196
- 66 layout tests total (exceeds ~35 target): 6 structs x (size + alignment + per-field offsets + nonzero round-trip) + 4 cross-struct consistency checks
- MSL header validated via xcrun metal compiler with static_assert for all 6 struct sizes + __builtin_offsetof for all 45 field offsets -- byte-identical to Rust
- MAX_GROUPS=64 is the query cardinality limit; array sizes use 256 (MAX_GROUP_SLOTS) for OutputBuffer.group_keys and agg_results
- build.rs uses `-I shaders/` include path so autonomous_types.h is available to any .metal file via `#include "autonomous_types.h"`
- Added rerun-if-changed for autonomous_types.h in build.rs
- WorkQueue uses alloc pattern from encode.rs: MTLResourceOptions::StorageModeShared + newBufferWithLength_options
- buffer.contents().as_ptr() returns NonNull<c_void>, cast to *mut u8 for byte-level access
- buffer.length() returns buffer size (used in tests to verify 1536 bytes)
- write_volatile + Release fence for sequence_id-last write ordering; read_volatile + Acquire fence for readback
- 13 unit tests for work queue (exceeds ~12 target): buffer alloc, shared mode, write_idx cycling, sequence_id monotonic, slot population, wraparound, zero-init
- BinaryColumnarLoader converts ColumnarBatch (per-type separate buffers) into single contiguous Metal buffer with ColumnMeta array
- Column alignment: 16-byte per column offset, page-aligned (16KB) total buffer
- ColumnarBatch already stores floats as f32 (not f64), so FLOAT64 copy is direct (no downcast needed)
- Dictionary values extracted from ColumnarBatch.dictionaries[global_col_idx] -- must use global not local index
- newBufferWithLength_options returns Option (use ok_or_else for Result), unlike encode::alloc_buffer which panics
- 15 unit tests for loader (exceeds ~14 target): INT64/FLOAT32/VARCHAR round-trip, multi-column, alignment, page-alignment, 1K rows, progress channel, empty table, meta buffer, schema preservation, non-overlap, align_up
- Foundation checkpoint: 901 total tests (807 existing + 94 autonomous), 0 failures. All foundation components verified working together.
- Fused query kernel: single-pass filter+aggregate+GROUP BY in one kernel dispatch. 5 phases: init accumulators, filter (AND compound up to 4 predicates), GROUP BY bucketing (modular hash into 64 slots), simd reduction + threadgroup merge, device atomic global reduction.
- build.rs auto-discovers .metal files -- no explicit listing needed for new shaders
- GroupAccumulator struct = 64 bytes, threadgroup array of 64 = 4096 bytes (well under 32KB limit)
- 64-bit device atomics via split lo/hi uint32 pattern: atomic_add uses carry propagation, atomic_min/max use CAS loops
- Float device atomics via CAS loop on uint bit representation (as_type<float/uint>)
- Threadgroup completion tracking: use atomic counter in output buffer, last threadgroup sets metadata + ready_flag
- threadgroup_barrier(mem_flags::mem_device) needed before final atomic increment to ensure device memory writes visible
- FusedPsoCache follows pipeline.rs pattern: MTLFunctionConstantValues + setConstantValue_type_atIndex + newFunctionWithName_constantValues_error + newComputePipelineStateWithFunction_error
- Function constants: index 0 = FILTER_COUNT (UInt), index 1 = AGG_COUNT (UInt), index 2 = HAS_GROUP_BY (Bool as u8)
- library.device() returns the device from any library reference -- no need to store device separately for PSO creation
- After cargo clean, fused_query.metal compiles and is included in metallib. Stale metallib from pre-fused_query builds won't contain the function.
- 5 PSO tests: headline compilation, cache hit, different constants, no-filter/no-groupby, max config (4 filters, 5 aggs, group_by)

## Next
Task 2.3: Implement one-shot fused kernel dispatch
