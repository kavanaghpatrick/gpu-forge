# KB Coverage Audit: gpu-particle-system

Analysis of what percentage of actual engineering work was covered by the gpu-forge
knowledge base (KB) versus figured out from scratch during implementation.

---

## 1. Per-File Component Analysis

### Production Code (excluding inline tests)

| File | Total LOC | Prod LOC | Domain | KB Coverage | Complexity | Bug Risk |
|------|-----------|----------|--------|-------------|------------|----------|
| `src/main.rs` | 535 | 535 | Metal API, Rust-ObjC FFI, event loop | Partial | High | High |
| `src/gpu.rs` | 221 | 221 | Metal API, pipeline setup, Rust-ObjC FFI | Partial | High | Medium |
| `src/buffers.rs` | 468 | 339 | Metal buffers, unified memory, pool mgmt | Covered | Medium | Medium |
| `src/frame.rs` | 138 | 138 | GPU/CPU sync, semaphores | Covered | Medium | High |
| `src/input.rs` | 642 | 262 | Windowing, input, unproject math | Uncovered | Medium | Low |
| `src/types.rs` | 283 | 152 | Rust-MSL struct layout, alignment | Partial | Medium | High |
| `src/camera.rs` | 400 | 88 | 3D math, orbit camera | Uncovered | Low | Low |
| `shaders/emission.metal` | 125 | 125 | MSL, atomics, PRNG | Covered | High | High |
| `shaders/update.metal` | 156 | 156 | MSL, physics, grid sampling | Covered | High | High |
| `shaders/render.metal` | 112 | 112 | MSL, vertex/fragment, billboard math | Partial | Medium | Medium |
| `shaders/grid.metal` | 84 | 84 | MSL, atomics, spatial hashing | Covered | Medium | Medium |
| `shaders/prng.metal` | 25 | 25 | MSL, PRNG algorithm | Covered | Low | Low |
| `shaders/types.h` | 66 | 66 | MSL struct layout | Partial | Medium | High |
| `build.rs` | 85 | 85 | Rust build system, xcrun toolchain | Uncovered | Low | Medium |
| `Cargo.toml` | 16 | 16 | Rust deps, objc2 ecosystem | Partial | Low | Low |

### Test Code

| File | Test LOC | Domain | KB Coverage |
|------|----------|--------|-------------|
| `tests/gpu_integration.rs` | 1036 | Metal API, GPU compute dispatch, buffer readback | Uncovered |
| `src/buffers.rs` (tests) | 129 | Buffer allocation verification | Partial |
| `src/input.rs` (tests) | 380 | Input state, physics params, unproject | Uncovered |
| `src/types.rs` (tests) | 131 | Struct layout verification | Partial |
| `src/camera.rs` (tests) | 312 | Camera math verification | Uncovered |
| **Test subtotal** | **1988** | | |

---

## 2. KB Coverage Classification Detail

### Covered: KB had directly relevant findings applied during implementation

| Component | KB Source | What KB Provided |
|-----------|----------|------------------|
| **Atomic free lists** (emission, update, grid) | KB 190, 283, 328 | Lock-free append pattern with atomic_uint at buffer[0], 16-byte aligned counter header, threadgroup pre-aggregation strategy |
| **SoA buffer layout** | KB 266, 268 | Cache line = 128B, SoA preferred over AoS for partial reads, coalesced access improves bandwidth |
| **Mixed FP16/FP32 precision** | KB 263, 313 | FP16 halves register consumption, dual-issue on Family 9, half/ushort use 2x fewer registers |
| **Unified memory (StorageModeShared)** | KB 125, 153 | Zero-copy CPU<->GPU, hardware cache coherence, no explicit flushes needed |
| **Semaphore ring (frame sync)** | KB 232 | dispatch_semaphore pattern, triple buffering canonical, signal in completion handler |
| **Serial command buffer strategy** | KB 137, 138 | 1 command buffer/frame, serial dispatch gives implicit coherence |
| **PRNG on GPU** | KB (PRNG guidance) | Hash-based GPU PRNG eliminates CPU->GPU sync for randomness |
| **Ping-pong buffer swap** | KB (particle system refs) | Two alive lists, swap roles each frame, eliminates read-write hazards |
| **Indirect draw args** | KB 148, 150 | GPU-written indirect args, MTLDrawPrimitivesIndirectArguments layout |
| **Grid density field** | KB (histogram.metal.tmpl) | 64^3 spatial hash, atomic increments, pressure gradient from neighbor reads |
| **Threadgroup sizing** | KB 157, 259, 310 | 256 threads (8 SIMD groups), <104 registers for 2 threadgroups/core |

**Covered prod LOC**: buffers.rs (339) + frame.rs (138) + emission.metal (125) + update.metal (156) + grid.metal (84) + prng.metal (25) = **867 LOC**

### Partial: KB had some relevant findings but significant gaps remained

| Component | What KB Covered | What KB Missed |
|-----------|----------------|----------------|
| **main.rs (event loop + dispatch orchestration)** | Command buffer encoding pattern, dispatch order, single buffer/frame | winit 0.30 ApplicationHandler API, window event handling, camera/input integration, specific buffer binding indices, redraw scheduling |
| **gpu.rs (Metal device + pipeline init)** | Pipeline creation pattern (newComputePipelineStateWithFunction) | CAMetalLayer creation/attachment to NSView via msg_send!, newLibraryWithFile_error API, alpha blend setup, depth stencil config, metallib path resolution |
| **types.rs/types.h (Uniforms struct)** | MSL float3 = 16 bytes in structs, alignment rules | Specific byte-by-byte Rust<->MSL matching with explicit padding fields, the 256-byte target, exact field ordering for all 25+ fields |
| **render.metal (vertex/fragment)** | Billboard quad concept, instanced rendering | Camera right/up extraction from view matrix rows (transposed column access), world-space billboard offset math, lifetime-based size shrink formula, half4 color passthrough |
| **Cargo.toml** | objc2-metal + winit + glam recommendations | block2, dispatch2 as required direct deps, objc2-quartz-core and objc2-core-foundation as separate deps |

**Partial prod LOC**: main.rs (535) + gpu.rs (221) + types.rs (152) + types.h (66) + render.metal (112) + Cargo.toml (16) = **1102 LOC**

### Uncovered: KB had nothing relevant; figured out from scratch

| Component | What Had to Be Figured Out |
|-----------|---------------------------|
| **input.rs (InputState + PhysicsParams)** | winit 0.30 event API, cursor tracking with prev position, right-drag for orbit, shift modifier tracking, physics parameter keyboard mapping (G/D/A/R/E keys), unproject_cursor_to_world (NDC -> inverse VP -> z=0 plane intersection) |
| **camera.rs (OrbitCamera)** | Spherical coordinate orbit (azimuth/elevation/distance), eye position from trig, view/projection matrix via glam, zoom clamping, elevation clamping near poles |
| **build.rs (Metal shader compilation)** | xcrun -sdk macosx metal -c for .metal->.air, xcrun metallib for .air->.metallib, header include path (-I), rerun-if-changed directives, .metal file discovery |
| **tests/gpu_integration.rs** | Self-contained test context with device/queue/pipeline, EmissionBuffers + PhysicsBuffers setup/teardown, metallib discovery from deps/ directory, all assertion patterns, half2 manipulation for forcing death, waitUntilCompleted() pattern for sync tests |

**Uncovered prod LOC**: input.rs (262) + camera.rs (88) + build.rs (85) = **435 LOC**

---

## 3. LOC Summary by Domain

### Production Code by Technical Domain

| Domain | Files | Prod LOC | % of Total Prod | KB Coverage |
|--------|-------|----------|-----------------|-------------|
| **Metal API / Rust-ObjC FFI** | main.rs, gpu.rs | 756 | 31.4% | Partial |
| **MSL Compute Kernels** | emission.metal, update.metal, grid.metal, prng.metal | 390 | 16.2% | Covered |
| **MSL Render Shaders** | render.metal | 112 | 4.7% | Partial |
| **MSL/Rust Struct Layout** | types.rs, types.h | 218 | 9.1% | Partial |
| **GPU Buffer Management** | buffers.rs | 339 | 14.1% | Covered |
| **GPU/CPU Synchronization** | frame.rs | 138 | 5.7% | Covered |
| **Input / Interaction** | input.rs | 262 | 10.9% | Uncovered |
| **3D Math / Camera** | camera.rs | 88 | 3.7% | Uncovered |
| **Build System** | build.rs, Cargo.toml | 101 | 4.2% | Uncovered |
| **Total Production** | | **2404** | **100%** | |

### Test Code by Domain

| Domain | Files | Test LOC | KB Coverage |
|--------|-------|----------|-------------|
| GPU Integration Tests | gpu_integration.rs | 1036 | Uncovered |
| Input/Physics Unit Tests | input.rs tests | 380 | Uncovered |
| Camera Unit Tests | camera.rs tests | 312 | Uncovered |
| Buffer Unit Tests | buffers.rs tests | 129 | Partial |
| Types Unit Tests | types.rs tests | 131 | Partial |
| **Total Test** | | **1988** | |

### Grand Total

| Category | LOC | % of All Code |
|----------|-----|---------------|
| Production | 2404 | 54.7% |
| Test | 1988 | 45.3% |
| **Grand Total** | **4392** | **100%** |

---

## 4. KB Coverage by LOC

### Production Code Only (2404 LOC)

| Coverage Level | Prod LOC | % of Prod |
|----------------|----------|-----------|
| **Covered** (KB directly applicable) | 867 | 36.1% |
| **Partial** (KB gave foundation, gaps remained) | 1102 | 45.8% |
| **Uncovered** (figured out from scratch) | 435 | 18.1% |

### All Code Including Tests (4392 LOC)

| Coverage Level | LOC | % of Total |
|----------------|-----|------------|
| **Covered** | 867 | 19.7% |
| **Partial** | 1362 | 31.0% |
| **Uncovered** | 2163 | 49.3% |

**Interpretation**: KB directly covered ~36% of production code. With partial coverage (where KB provided the conceptual framework but not the implementation specifics), the KB influenced ~82% of production code. However, when test code is included, nearly half the engineering (49%) was completely outside KB scope.

---

## 5. Bug Analysis

### Documented Bugs from .progress.md

| # | Bug | Domain | KB Coverage | Severity | File(s) |
|---|-----|--------|-------------|----------|---------|
| 1 | MSL `float3*` uses 16-byte stride but Rust allocated 12B/particle; must use `packed_float3*` | MSL/Rust struct alignment | Partial | CRITICAL | update.metal, emission.metal, render.metal |
| 2 | Dead list atomic underflow: `prev_count <= 0u` fails for uint wrap-around on atomic_fetch_sub | MSL atomics | Covered | CRITICAL | emission.metal |
| 3 | Triple-buffer race condition: shared SoA buffers + 3 in-flight frames caused data corruption | GPU/CPU sync | Covered | CRITICAL | frame.rs, main.rs |
| 4 | CPU readback of alive count between emission and render fails (GPU hasn't executed yet) | Metal command model | Covered | CRITICAL | main.rs, render.metal |
| 5 | sizes buffer allocated at pool_size*4 (FP32) but shaders use `half` (2-byte stride) | MSL/Rust buffer sizing | Partial | Medium | buffers.rs, types.rs |
| 6 | Cumulative size multiplication in update kernel would shrink particles exponentially | Particle system logic | Uncovered | Medium | render.metal |
| 7 | objc2-metal v0.3 does NOT have "all" feature flag | Rust-ObjC FFI | Uncovered | Low | Cargo.toml |
| 8 | cargo clean needed when adding new .metal files | Build system | Uncovered | Low | build.rs |
| 9 | Two-phase grid histogram infeasible (262K bins > 32KB threadgroup memory) | MSL optimization | Covered* | Medium | grid.metal |

*Bug 9: KB's histogram.metal.tmpl suggested two-phase pattern, but the design incorrectly applied it to a 262K-bin scenario. The KB finding was correct for small bin counts but the design misapplied it. This is a design-level error where KB guidance was actually misleading.

### Bug Distribution by KB Coverage

| KB Coverage | Bug Count | Critical Bugs | % of All Bugs |
|-------------|-----------|---------------|---------------|
| Covered | 3 (bugs 2,3,4) | 3 | 33% |
| Partial | 2 (bugs 1,5) | 1 | 22% |
| Uncovered | 3 (bugs 6,7,8) | 0 | 33% |
| Misleading* | 1 (bug 9) | 0 | 11% |

### Bug Density by Domain

| Domain | Prod LOC | Bugs | Bug Density (per 100 LOC) | Critical |
|--------|----------|------|--------------------------|----------|
| MSL Compute Kernels | 390 | 3 (1, 2, 9) | **0.77** | 1 |
| GPU/CPU Sync | 138 | 1 (3) | **0.72** | 1 |
| Metal API / FFI | 756 | 2 (4, 7) | 0.26 | 1 |
| MSL/Rust Struct Layout | 218 | 1 (5) | 0.46 | 0 |
| MSL Render Shaders | 112 | 1 (6) | **0.89** | 0 |
| GPU Buffer Mgmt | 339 | 0 | 0.00 | 0 |
| Build System | 101 | 1 (8) | 0.99 | 0 |
| Input / Camera | 350 | 0 | 0.00 | 0 |

**Highest bug density**: MSL render shaders (0.89), build system (0.99, but low severity), MSL compute kernels (0.77), GPU/CPU sync (0.72).

---

## 6. Critical Bug Deep-Dive

All 4 CRITICAL bugs occurred in KB-covered or partial-covered domains:

### Bug 1: packed_float3 vs float3 stride mismatch (Partial coverage)
- **KB had**: MSL float3 = 16 bytes in structs with padding
- **KB missed**: The distinction between `device float3*` (16-byte stride in arrays) vs `device packed_float3*` (12-byte stride) is a subtle MSL-specific gotcha not covered
- **Impact**: All particles rendered at wrong positions; complete visual corruption
- **Fix difficulty**: Easy once diagnosed, but diagnosis required understanding MSL memory layout at array level (not struct level)

### Bug 2: Atomic uint underflow wrap-around (Covered domain)
- **KB had**: Lock-free atomic append pattern, atomic_uint at buffer start
- **KB missed**: Nothing -- this was a logic error in applying the pattern. `prev_count <= 0u` is always false for unsigned int. The correct guard is `prev_count == 0 || prev_count > pool_size`
- **Root cause**: Programming error in unsigned integer comparison
- **Impact**: Dead list counter wraps to UINT_MAX, mass particle corruption

### Bug 3: Triple-buffer race on shared buffers (Covered domain)
- **KB had**: Triple buffering with dispatch_semaphore(3)
- **KB missed**: The canonical triple-buffer pattern assumes **per-frame buffers**. The particle system shares SoA buffers across all frames. KB correctly described the pattern but the application context was different.
- **Root cause**: Applying triple-buffer pattern without per-frame buffer partitioning
- **Impact**: Random data corruption, visual glitches
- **Resolution**: Downgraded to single buffering (still 120 FPS on M4 Pro)

### Bug 4: CPU readback before GPU execution (Covered domain)
- **KB had**: Command buffer execution model, no CPU readback
- **Discovery**: Attempting to read alive_list counter CPU-side between encoding emission and render fails because GPU hasn't run yet
- **Fix**: sync_indirect_args compute kernel (1 thread) copies counter to indirect args on GPU
- **Impact**: Zero particles rendered (instanceCount always 0)

---

## 7. Design vs Implementation Divergences

The design.md specified several patterns that were changed during implementation:

| Design Specification | Actual Implementation | Reason |
|---------------------|----------------------|--------|
| Two-phase grid histogram (threadgroup + merge) | Single-phase global atomics | 262K bins exceeds 32KB threadgroup memory |
| Prefix scan compaction kernel | Atomic append in update kernel (no separate compact.metal) | Update kernel's atomic append IS the compaction; simpler and sufficient |
| Triple buffering (semaphore=3) | Single buffering (semaphore=1) | Shared SoA buffers race with >1 in-flight frame |
| Separate compact.metal shader | Eliminated; sync_indirect_args in render.metal | Compaction folded into update kernel's dead/alive list management |
| 7 shader files (including compact.metal) | 5 shader files + 1 header | compact.metal never needed |
| Billboard quad in clip space | Billboard quad in world space | World-space billboards are more physically correct |

All 6 divergences were in KB-covered or partial-covered domains. The KB provided correct general patterns, but the specific application context required adaptation.

---

## 8. Where KB Was Most/Least Valuable

### Most Valuable KB Contributions
1. **Atomic free list pattern** (KB 190): The counter-at-buffer-start + index array pattern was used unchanged in dead_list, alive_list_a, alive_list_b. Core to the entire system.
2. **StorageModeShared for unified memory** (KB 125, 153): Zero-copy CPU<->GPU access pattern used everywhere. No time wasted investigating Private/Managed modes.
3. **Serial command buffer = implicit coherence** (KB 137): Eliminated entire class of synchronization bugs by keeping 1 command buffer per frame.
4. **Threadgroup size = 256** (KB 157, 310): Applied uniformly to all compute dispatches. Correct choice validated by profiling.
5. **FP16/FP32 dual-issue** (KB 263): Mixed precision strategy saved ~33% bandwidth; validated by Family 9 hardware.

### Least Valuable / Misleading KB Contributions
1. **Two-phase grid histogram** (histogram.metal.tmpl): Suggested for grid populate, but infeasible at 64^3 bin count. Design followed KB recommendation, implementation had to abandon it.
2. **Triple buffering** (KB 232): Correct pattern in general, but misapplied without per-frame buffer partitioning. Led to critical race condition (bug 3).
3. **Metal 4 research**: Entire Metal 4 section in research.md was wasted effort; implementation targeted Metal 3 exclusively.

### Entirely Missing from KB
1. **objc2-metal v0.3 API specifics**: Every FFI call (setBuffer_offset_atIndex, newComputePipelineStateWithFunction_error, msg_send! for NSView layer attachment) was figured out from crate docs and compiler errors.
2. **winit 0.30 ApplicationHandler pattern**: No KB coverage of the Rust windowing ecosystem.
3. **build.rs Metal shader compilation**: xcrun toolchain invocation, .air intermediate format, metallib linking -- all discovered from Apple docs.
4. **packed_float3 vs float3 in MSL arrays**: The single most impactful missing KB finding. Cost a critical bug.
5. **All test infrastructure**: 1988 LOC of tests had zero KB guidance.

---

## 9. Summary Statistics

```
PRODUCTION CODE: 2,404 LOC
  KB Covered:    867 LOC (36%)
  KB Partial:  1,102 LOC (46%)
  KB Uncovered:  435 LOC (18%)

TEST CODE: 1,988 LOC
  KB Covered:      0 LOC  (0%)
  KB Partial:    260 LOC (13%)
  KB Uncovered: 1,728 LOC (87%)

ALL CODE: 4,392 LOC
  KB Covered:    867 LOC (20%)
  KB Partial:  1,362 LOC (31%)
  KB Uncovered: 2,163 LOC (49%)

BUGS: 9 total, 4 critical
  In KB-covered domains: 4 bugs (3 critical)
  In partial domains:    2 bugs (1 critical)
  In uncovered domains:  3 bugs (0 critical)
  KB-misleading:         1 bug  (0 critical)

BUG DENSITY (per 100 prod LOC):
  KB-covered domains:  0.46  (4 bugs / 867 LOC)
  Partial domains:     0.18  (2 bugs / 1102 LOC)
  Uncovered domains:   0.69  (3 bugs / 435 LOC)
```

---

## 10. Key Findings

1. **KB influenced 82% of production code** (covered + partial), but only 36% had
   directly applicable guidance. The remaining 46% required significant adaptation.

2. **All 4 critical bugs occurred in KB-influenced areas**, not in uncovered areas.
   This suggests the hardest engineering problems were in applying KB-recommended
   patterns to the specific application context, not in the "from scratch" domains.

3. **The uncovered domains (input, camera, build system) had zero critical bugs**.
   These were straightforward Rust/math code where standard programming competence
   sufficed.

4. **Highest bug density was in MSL shader code (0.77-0.89 per 100 LOC)** -- the
   domain where Rust and MSL memory models collide. The KB covered the MSL side
   well but missed the Rust<->MSL interface subtleties (packed_float3, uint
   underflow semantics).

5. **49% of total engineering (including tests) was outside KB scope**. Test
   infrastructure, build system, and UI/interaction code had to be figured out
   entirely from external docs and experimentation.

6. **The KB's most impactful blind spot** was `packed_float3` vs `float3` in MSL
   arrays. This single missing finding caused the most damaging bug (bug 1). A KB
   entry on MSL array stride rules would have prevented it.

7. **Two KB recommendations were actively misleading** in this context: the
   two-phase histogram pattern (infeasible at 262K bins) and triple buffering
   (races without per-frame buffer copies). Both required implementation-time
   course correction.
