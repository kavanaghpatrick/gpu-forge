# Progress: gpu-search

## Original Goal

Build a GPU-accelerated filesystem search tool (gpu-search) as a standalone Rust project at gpu_kernel/gpu-search/. Reuse GPU backend from rust-experiment project -- port Metal compute search kernels (vectorized uchar4 matching, SIMD prefix sum, 55-80 GB/s), MTLIOCommandQueue batch file loading, GPU-resident filesystem index, streaming search pipeline, and persistent kernel batch variant to objc2-metal. CPU renders UI via egui/eframe floating panel (Spotlight-style, global hotkey). Both filename + content search from day one. Fixed string matching for MVP. Respects .gitignore by default. Full foreman spec analysis exists in ai/tasks/spec/ (PM.md, UX.md, TECH.md, QA.md, OVERVIEW.md) -- synthesize research/requirements/design/tasks from those 4 comprehensive artifacts (59 tasks across 7 modules). Key decisions: objc2-metal clean port, egui floating panel with dark Tokyo Night theme, triple-buffered work queue from gpu-query, completion-handler re-dispatch, MTLSharedEvent idle/wake, JIT PSO cache, syntect for syntax highlighting, virtual scroll for 10K results, Criterion benchmarks with ripgrep comparison. Search-as-you-type <5ms latency target.

## Current Phase
execution

## Reality Check (BEFORE)

**Goal type**: Add
**Classification**: New standalone project -- GPU-accelerated filesystem search tool
**No reproduction needed**: This is a greenfield build, not a fix.

## Completed Tasks
- [x] 1.1 Create project directory structure
- [x] 1.2 Create Cargo.toml with all dependencies
- [x] 1.3 Create build.rs for Metal shader compilation
- [x] 1.4 Create placeholder Metal shader files
- [x] 1.5 Create stub main.rs and lib.rs
- [x] 1.6 Port gpu/device.rs -- Metal device initialization
- [x] 1.7 Create gpu/types.rs -- shared repr(C) types
- [x] 1.8 Port gpu/pipeline.rs -- PSO cache
- [x] 1.9 Extract Metal shaders from rust-experiment
- [x] 1.10 Port io/mmap.rs -- zero-copy mmap buffers
- [x] 1.11 Port io/gpu_io.rs -- MTLIOCommandQueue
- [x] 1.12 Port io/batch.rs -- batch file loading
- [x] 1.13 Port search/content.rs -- content search orchestration
- [x] 1.14 Port search/streaming.rs -- streaming pipeline
- [x] 1.15 Define search API types
- [x] 1.16 POC Checkpoint: end-to-end GPU search

## Current Task
Awaiting next task

## Learnings

- Comprehensive foreman analysis already exists at `ai/tasks/spec/` with 4 specialized agent outputs (PM, UX, TECH, QA) totaling ~3,500 lines
- 7 BREAKDOWN files provide module-level task decomposition with ~59 tasks across devops, gpu-engine, search-core, ui, index, bench, integration
- PM.md is for gpu-query (autonomous query engine), NOT gpu-search -- used for pattern reference only
- UX.md recommends iced framework, but user decision overrides to egui/eframe -- respected user Q&A decisions
- TECH.md provides comprehensive API translation table (metal 0.33 -> objc2-metal 0.3) and dual-Metal architecture design
- QA.md estimates ~385 tests across 6 dimensions with GPU-CPU dual verification as core pattern
- Source port is ~8,000 lines from rust-experiment, with MSL shader algorithms UNCHANGED
- Key risk: objc2-metal MTLIOCommandQueue bindings may be incomplete -- msg_send! fallback documented
- gpu-query at gpu_kernel/gpu-query/ provides direct reference for objc2-metal patterns (device, pipeline, work_queue, executor, build.rs)
- rust-experiment source files confirmed at expected paths with expected line counts
- Port order matters: device -> types -> mmap (simplest) -> gpu_io (complex msg_send! replacement) -> batch -> content_search -> streaming
- Cargo.toml: objc2-metal 0.3.2, eframe 0.31.1, syntect 5.3.0 all resolve cleanly; 481 packages total; bench stubs needed for cargo check to pass
- Cache location changes from ~/.gpu_os/ (rust-experiment) to ~/.gpu-search/ (new tool)
- Synthesized 52 tasks across 5 phases from 7 BREAKDOWN files, consolidating overlapping tasks
- Phase 1 (POC) has 16 tasks focused on scaffold + GPU engine port + basic search pipeline
- Phase 2 (Feature Complete) has 23 tasks for UI, orchestrator, index, filters, error handling
- Phase 3 (Testing) has 7 tasks for GPU-CPU verification, edge cases, stress tests
- Phase 4 (Quality Gates) has 8 tasks for benchmarks, CI, regression detection
- Project scaffold at gpu_kernel/gpu-search/ with 5 module dirs (gpu, search, io, index, ui), shaders/, tests/, benches/
- build.rs compiles .metal -> .air -> .metallib; with no .metal files it creates a stub metallib so downstream code can always load the library
- Metal shader stubs: search_types.h defines SearchParams (256B pattern, total_bytes, case_sensitive, max_matches, file_count), GpuMatchResult (file_index, byte_offset, line_number, column, match_length, context), GpuPathEntry (224B path, flags, parent_idx, size, mtime = 256B total)
- 4 kernel stubs compile cleanly: content_search_kernel, turbo_search_kernel, batch_search_kernel, path_filter_kernel
- GpuDevice ported from gpu-query: MTLCreateSystemDefaultDevice + capability queries (maxThreadsPerThreadgroup, maxBufferLength, maxThreadgroupMemoryLength). All default features in objc2-metal 0.3.2 include MTLDevice + MTLTypes so no extra feature flags needed.
- Apple M4 Pro reports: 1024x1024x1024 max threadgroup, 27648 MB max buffer, 32 KB threadgroup memory

- Rust repr(C) types must match search_types.h exactly -- GpuPathEntry uses split u32 size_lo/size_hi (not u64) and u32 mtime to match Metal uint types
- SearchParams is 284 bytes: 256 (pattern) + 5x4 (fields) + 2x4 (reserved)
- GpuMatchResult is 32 bytes (8 x u32), GpuPathEntry is 256 bytes
- Compile-time const assertions catch layout drift before runtime
- PsoCache loads shaders.metallib via find_metallib() (same pattern as gpu-query device.rs) and eagerly compiles PSOs for all 4 kernels
- gpu-search PSO cache is simpler than gpu-query's -- no function constants, just function name keyed HashMap
- Must cargo clean when shader stubs change, otherwise cached stub metallib may lack real kernel functions
- Shader extraction: content_search_kernel and turbo_search_kernel from content_search.rs CONTENT_SEARCH_SHADER (vectorized uchar4, SIMD prefix sum, 64 bytes/thread)
- Shader extraction: batch_search_kernel from persistent_search.rs PERSISTENT_SEARCH_SHADER (threadgroup per work item, PersistentKernelControl/SearchWorkItem structs)
- Shader extraction: path_filter_kernel adapted from filesystem.rs fuzzy_search_kernel pattern, using GpuPathEntry (256B) struct with substring matching + SIMD reduction
- search_types.h now contains ALL shared structs: ChunkMetadata, SearchParams (4 uint fields), MatchResult, SearchWorkItem, PersistentKernelControl, DataBufferDescriptor, GpuPathEntry, PathFilterParams, and shared char_eq_fast() utility
- Note: search_types.h SearchParams (4 x uint) differs from Rust types.rs SearchParams (284 bytes with 256B pattern) -- will need reconciliation when wiring kernels to Rust dispatch code in task 1.13
- Metal requires explicit address space qualifiers on pointer params in helper functions (use `thread const uchar*` for local data)
- Metal `max()` is ambiguous between int/uint overloads when using #define constants; cast with `(uint)` to resolve
- MmapBuffer ported from rust-experiment with gpu-query patterns: uses NonNull + newBufferWithBytesNoCopy_length_options_deallocator with copy fallback via newBufferWithBytes_length_options
- Apple Silicon page size is 16KB (not 4KB as in rust-experiment) -- gpu-query uses 16384 and so does gpu-search
- MmapBuffer decoupled from Device: from_file() doesn't take device, as_metal_buffer() takes device -- cleaner API than rust-experiment's combined constructor
- from_bytes() useful for tests: anonymous mmap + copy + mprotect read-only, avoids needing real files

- objc2-metal 0.3.2 has COMPLETE MTLIOCommandQueue bindings: MTLIOCommandQueueDescriptor, MTLIOCommandQueue, MTLIOCommandBuffer, MTLIOFileHandle, MTLIOPriority, MTLIOStatus -- all default features. Zero msg_send! needed.
- Key API translations: `newIOCommandQueueWithDescriptor_error`, `newIOFileHandleWithURL_error`, `loadBuffer_offset_size_sourceHandle_sourceHandleOffset`, `newBufferWithLength_options` (NOT `newBuffer_length_options`)
- NSURL::fileURLWithPath(&NSString) replaces raw class!(NSURL) + msg_send! pattern
- objc2-metal error handling: methods return Result<Retained<T>, Retained<NSError>> instead of raw pointer + separate error outparam
- MTLIOCommandQueue confirmed working on Apple M4 Pro: 8KB and 1MB file loads complete in <20ms total test time

- Batch loader groups files into 64-per-MTLIOCommandBuffer batches; files allocated page-aligned (16KB) into a single mega-buffer
- newBufferWithBytes_length_options is unsafe in objc2-metal (requires unsafe block); newBufferWithLength_options is safe
- GpuBatchSearchBuffer provides path->index HashMap for O(1) file lookup in search results
- Batch load of 100 temp files completes in <40ms on M4 Pro, all contents verified byte-for-byte
- Graceful failure handling: empty files, nonexistent paths, >100MB files are skipped and reported in failed_files

- Metal SearchParams in search_types.h is 16 bytes (4 x uint: chunk_count, pattern_len, case_sensitive, total_bytes) -- DIFFERENT from Rust types.rs SearchParams (284 bytes with 256B pattern array)
- Content search uses local GpuSearchParams (16B) matching the Metal shader layout, not the large Rust SearchParams
- GPU kernel line numbers are LOCAL to each thread's 64-byte window, not global file lines. Full line resolution deferred to orchestrator
- Matches crossing 64-byte thread boundaries will be missed by the GPU kernel -- known limitation, ~2-5% miss rate on real files
- objc2-metal requires importing trait MTLCommandBuffer for .commit()/.waitUntilCompleted()/.computeCommandEncoder(), MTLCommandEncoder for .endEncoding()
- MTLSize fields are `usize` in objc2-metal (not u64 as in older metal crate)
- ContentSearchEngine uses pre-allocated StorageModeShared buffers reused across searches to avoid per-search allocation
- Both standard (content_search_kernel) and turbo (turbo_search_kernel) modes verified working -- turbo defers line numbers to CPU for max throughput
- GPU-CPU dual verification: 7 tests covering standard/turbo/case-insensitive/no-match/empty/multi-file/real-file all pass

- Streaming pipeline uses quad-buffered StreamChunks (4 x 64MB) with ContentSearchEngine for GPU dispatch
- Files partitioned by cumulative size into chunks; each chunk processes files in sub-batches of 200 to stay within MAX_MATCHES (10K) per GPU dispatch
- Sub-batching critical: without it, 17K files saturate the GPU match buffer (40K matches capped vs 148K actual)
- GPU thread-boundary miss rate is ~13% for 13-byte patterns due to 64-byte-per-thread architecture -- known kernel limitation
- Streaming search of 68MB (1087 files) completes in ~53ms = 1.3 GB/s throughput (includes CPU I/O)
- POC uses std::fs::read for I/O; Phase 2 will integrate MTLIOCommandQueue for true I/O-compute overlap
- 7 streaming tests: large data (>64MB), small files, no matches, partitioning, empty input, case insensitive, profiling

- POC end-to-end wiring: main.rs takes pattern+dir args, walks directory, runs StreamingSearchEngine, resolves GPU byte_offset to file:line:content
- StreamingMatch.byte_offset was engine-global (chunk_index * 4096 + context_start); fixed to track per-file start_chunk offset for correct file-relative offsets
- GPU miss rate ~1-7% on real source files due to 64-byte thread boundary limitation -- matches grep output within expected tolerance
- End-to-end pipeline: GpuDevice -> PsoCache (4 kernels) -> StreamingSearchEngine -> resolve_line -> grep-like stdout output
- Binary file extension filtering (metallib, air, images, archives, etc.) prevents GPU from wasting time on non-text files
- resolve_line reads file, counts newlines up to byte_offset, extracts full line content -- simple but correct for POC
- 16 source files (0.13 MB) searched in ~6ms on M4 Pro; 158/160 "fn " matches found (98.75% hit rate)

## Next
Task 2.1: Port index/gpu_index.rs -- GPU-resident path index
