# Progress: gpu-search

## Original Goal

Build a GPU-accelerated filesystem search tool (gpu-search) as a standalone Rust project at gpu_kernel/gpu-search/. Reuse GPU backend from rust-experiment project -- port Metal compute search kernels (vectorized uchar4 matching, SIMD prefix sum, 55-80 GB/s), MTLIOCommandQueue batch file loading, GPU-resident filesystem index, streaming search pipeline, and persistent kernel batch variant to objc2-metal. CPU renders UI via egui/eframe floating panel (Spotlight-style, global hotkey). Both filename + content search from day one. Fixed string matching for MVP. Respects .gitignore by default. Full foreman spec analysis exists in ai/tasks/spec/ (PM.md, UX.md, TECH.md, QA.md, OVERVIEW.md) -- synthesize research/requirements/design/tasks from those 4 comprehensive artifacts (59 tasks across 7 modules). Key decisions: objc2-metal clean port, egui floating panel with dark Tokyo Night theme, triple-buffered work queue from gpu-query, completion-handler re-dispatch, MTLSharedEvent idle/wake, JIT PSO cache, syntect for syntax highlighting, virtual scroll for 10K results, Criterion benchmarks with ripgrep comparison. Search-as-you-type <5ms latency target.

## Current Phase
execution

## Reality Check (BEFORE)

**Goal type**: Add
**Classification**: New standalone project -- GPU-accelerated filesystem search tool
**No reproduction needed**: This is a greenfield build, not a fix.

## Completed Tasks
- [x] 1.1 Create project directory structure
- [x] 1.2 Create Cargo.toml with all dependencies
- [x] 1.3 Create build.rs for Metal shader compilation
- [x] 1.4 Create placeholder Metal shader files
- [x] 1.5 Create stub main.rs and lib.rs
- [x] 1.6 Port gpu/device.rs -- Metal device initialization
- [x] 1.7 Create gpu/types.rs -- shared repr(C) types
- [x] 1.8 Port gpu/pipeline.rs -- PSO cache
- [x] 1.9 Extract Metal shaders from rust-experiment
- [x] 1.10 Port io/mmap.rs -- zero-copy mmap buffers
- [x] 1.11 Port io/gpu_io.rs -- MTLIOCommandQueue
- [x] 1.12 Port io/batch.rs -- batch file loading
- [x] 1.13 Port search/content.rs -- content search orchestration
- [x] 1.14 Port search/streaming.rs -- streaming pipeline
- [x] 1.15 Define search API types
- [x] 1.16 POC Checkpoint: end-to-end GPU search
- [x] 2.1 Port index/gpu_index.rs -- GPU-resident path index
- [x] 2.2 Port index/shared_index.rs -- shared index manager
- [x] 2.3 Implement index/scanner.rs -- parallel filesystem scanner
- [x] 2.4 Implement index/cache.rs -- binary index persistence
- [x] 2.5 Implement index/gpu_loader.rs -- GPU buffer loading
- [x] 2.6 Adopt gpu-query work queue pattern
- [x] 2.7 Implement SearchExecutor with re-dispatch chain
- [x] 2.8 Implement search orchestrator
- [x] 2.9 Implement .gitignore filtering
- [x] 2.10 Implement binary file detection
- [x] 2.11 Implement result ranking and progressive delivery
- [x] 2.12 Implement ui/app.rs -- egui application
- [x] 2.13 Implement ui/theme.rs -- Tokyo Night dark theme
- [x] 2.14 Implement ui/search_bar.rs -- search input with debounce
- [x] 2.15 Implement ui/results_list.rs -- scrollable results
- [x] 2.16 Implement ui/keybinds.rs -- keyboard shortcuts
- [x] 2.17 Implement ui/highlight.rs -- syntax highlighting
- [x] 2.18 Implement ui/status_bar.rs and ui/filters.rs
- [x] 2.19 Wire GPU engine -> orchestrator -> UI
- [x] 2.20 Implement open-in-editor action
- [x] 2.21 Implement search cancellation

## Current Task
Awaiting next task

## Recently Completed
- [x] 2.21 Implement search cancellation

## Learnings

- Comprehensive foreman analysis already exists at `ai/tasks/spec/` with 4 specialized agent outputs (PM, UX, TECH, QA) totaling ~3,500 lines
- 7 BREAKDOWN files provide module-level task decomposition with ~59 tasks across devops, gpu-engine, search-core, ui, index, bench, integration
- PM.md is for gpu-query (autonomous query engine), NOT gpu-search -- used for pattern reference only
- UX.md recommends iced framework, but user decision overrides to egui/eframe -- respected user Q&A decisions
- TECH.md provides comprehensive API translation table (metal 0.33 -> objc2-metal 0.3) and dual-Metal architecture design
- QA.md estimates ~385 tests across 6 dimensions with GPU-CPU dual verification as core pattern
- Source port is ~8,000 lines from rust-experiment, with MSL shader algorithms UNCHANGED
- Key risk: objc2-metal MTLIOCommandQueue bindings may be incomplete -- msg_send! fallback documented
- gpu-query at gpu_kernel/gpu-query/ provides direct reference for objc2-metal patterns (device, pipeline, work_queue, executor, build.rs)
- rust-experiment source files confirmed at expected paths with expected line counts
- Port order matters: device -> types -> mmap (simplest) -> gpu_io (complex msg_send! replacement) -> batch -> content_search -> streaming
- Cargo.toml: objc2-metal 0.3.2, eframe 0.31.1, syntect 5.3.0 all resolve cleanly; 481 packages total; bench stubs needed for cargo check to pass
- Cache location changes from ~/.gpu_os/ (rust-experiment) to ~/.gpu-search/ (new tool)
- Synthesized 52 tasks across 5 phases from 7 BREAKDOWN files, consolidating overlapping tasks
- Phase 1 (POC) has 16 tasks focused on scaffold + GPU engine port + basic search pipeline
- Phase 2 (Feature Complete) has 23 tasks for UI, orchestrator, index, filters, error handling
- Phase 3 (Testing) has 7 tasks for GPU-CPU verification, edge cases, stress tests
- Phase 4 (Quality Gates) has 8 tasks for benchmarks, CI, regression detection
- Project scaffold at gpu_kernel/gpu-search/ with 5 module dirs (gpu, search, io, index, ui), shaders/, tests/, benches/
- build.rs compiles .metal -> .air -> .metallib; with no .metal files it creates a stub metallib so downstream code can always load the library
- Metal shader stubs: search_types.h defines SearchParams (256B pattern, total_bytes, case_sensitive, max_matches, file_count), GpuMatchResult (file_index, byte_offset, line_number, column, match_length, context), GpuPathEntry (224B path, flags, parent_idx, size, mtime = 256B total)
- 4 kernel stubs compile cleanly: content_search_kernel, turbo_search_kernel, batch_search_kernel, path_filter_kernel
- GpuDevice ported from gpu-query: MTLCreateSystemDefaultDevice + capability queries (maxThreadsPerThreadgroup, maxBufferLength, maxThreadgroupMemoryLength). All default features in objc2-metal 0.3.2 include MTLDevice + MTLTypes so no extra feature flags needed.
- Apple M4 Pro reports: 1024x1024x1024 max threadgroup, 27648 MB max buffer, 32 KB threadgroup memory

- Rust repr(C) types must match search_types.h exactly -- GpuPathEntry uses split u32 size_lo/size_hi (not u64) and u32 mtime to match Metal uint types
- SearchParams is 284 bytes: 256 (pattern) + 5x4 (fields) + 2x4 (reserved)
- GpuMatchResult is 32 bytes (8 x u32), GpuPathEntry is 256 bytes
- Compile-time const assertions catch layout drift before runtime
- PsoCache loads shaders.metallib via find_metallib() (same pattern as gpu-query device.rs) and eagerly compiles PSOs for all 4 kernels
- gpu-search PSO cache is simpler than gpu-query's -- no function constants, just function name keyed HashMap
- Must cargo clean when shader stubs change, otherwise cached stub metallib may lack real kernel functions
- Shader extraction: content_search_kernel and turbo_search_kernel from content_search.rs CONTENT_SEARCH_SHADER (vectorized uchar4, SIMD prefix sum, 64 bytes/thread)
- Shader extraction: batch_search_kernel from persistent_search.rs PERSISTENT_SEARCH_SHADER (threadgroup per work item, PersistentKernelControl/SearchWorkItem structs)
- Shader extraction: path_filter_kernel adapted from filesystem.rs fuzzy_search_kernel pattern, using GpuPathEntry (256B) struct with substring matching + SIMD reduction
- search_types.h now contains ALL shared structs: ChunkMetadata, SearchParams (4 uint fields), MatchResult, SearchWorkItem, PersistentKernelControl, DataBufferDescriptor, GpuPathEntry, PathFilterParams, and shared char_eq_fast() utility
- Note: search_types.h SearchParams (4 x uint) differs from Rust types.rs SearchParams (284 bytes with 256B pattern) -- will need reconciliation when wiring kernels to Rust dispatch code in task 1.13
- Metal requires explicit address space qualifiers on pointer params in helper functions (use `thread const uchar*` for local data)
- Metal `max()` is ambiguous between int/uint overloads when using #define constants; cast with `(uint)` to resolve
- MmapBuffer ported from rust-experiment with gpu-query patterns: uses NonNull + newBufferWithBytesNoCopy_length_options_deallocator with copy fallback via newBufferWithBytes_length_options
- Apple Silicon page size is 16KB (not 4KB as in rust-experiment) -- gpu-query uses 16384 and so does gpu-search
- MmapBuffer decoupled from Device: from_file() doesn't take device, as_metal_buffer() takes device -- cleaner API than rust-experiment's combined constructor
- from_bytes() useful for tests: anonymous mmap + copy + mprotect read-only, avoids needing real files

- objc2-metal 0.3.2 has COMPLETE MTLIOCommandQueue bindings: MTLIOCommandQueueDescriptor, MTLIOCommandQueue, MTLIOCommandBuffer, MTLIOFileHandle, MTLIOPriority, MTLIOStatus -- all default features. Zero msg_send! needed.
- Key API translations: `newIOCommandQueueWithDescriptor_error`, `newIOFileHandleWithURL_error`, `loadBuffer_offset_size_sourceHandle_sourceHandleOffset`, `newBufferWithLength_options` (NOT `newBuffer_length_options`)
- NSURL::fileURLWithPath(&NSString) replaces raw class!(NSURL) + msg_send! pattern
- objc2-metal error handling: methods return Result<Retained<T>, Retained<NSError>> instead of raw pointer + separate error outparam
- MTLIOCommandQueue confirmed working on Apple M4 Pro: 8KB and 1MB file loads complete in <20ms total test time

- Batch loader groups files into 64-per-MTLIOCommandBuffer batches; files allocated page-aligned (16KB) into a single mega-buffer
- newBufferWithBytes_length_options is unsafe in objc2-metal (requires unsafe block); newBufferWithLength_options is safe
- GpuBatchSearchBuffer provides path->index HashMap for O(1) file lookup in search results
- Batch load of 100 temp files completes in <40ms on M4 Pro, all contents verified byte-for-byte
- Graceful failure handling: empty files, nonexistent paths, >100MB files are skipped and reported in failed_files

- Metal SearchParams in search_types.h is 16 bytes (4 x uint: chunk_count, pattern_len, case_sensitive, total_bytes) -- DIFFERENT from Rust types.rs SearchParams (284 bytes with 256B pattern array)
- Content search uses local GpuSearchParams (16B) matching the Metal shader layout, not the large Rust SearchParams
- GPU kernel line numbers are LOCAL to each thread's 64-byte window, not global file lines. Full line resolution deferred to orchestrator
- Matches crossing 64-byte thread boundaries will be missed by the GPU kernel -- known limitation, ~2-5% miss rate on real files
- objc2-metal requires importing trait MTLCommandBuffer for .commit()/.waitUntilCompleted()/.computeCommandEncoder(), MTLCommandEncoder for .endEncoding()
- MTLSize fields are `usize` in objc2-metal (not u64 as in older metal crate)
- ContentSearchEngine uses pre-allocated StorageModeShared buffers reused across searches to avoid per-search allocation
- Both standard (content_search_kernel) and turbo (turbo_search_kernel) modes verified working -- turbo defers line numbers to CPU for max throughput
- GPU-CPU dual verification: 7 tests covering standard/turbo/case-insensitive/no-match/empty/multi-file/real-file all pass

- Streaming pipeline uses quad-buffered StreamChunks (4 x 64MB) with ContentSearchEngine for GPU dispatch
- Files partitioned by cumulative size into chunks; each chunk processes files in sub-batches of 200 to stay within MAX_MATCHES (10K) per GPU dispatch
- Sub-batching critical: without it, 17K files saturate the GPU match buffer (40K matches capped vs 148K actual)
- GPU thread-boundary miss rate is ~13% for 13-byte patterns due to 64-byte-per-thread architecture -- known kernel limitation
- Streaming search of 68MB (1087 files) completes in ~53ms = 1.3 GB/s throughput (includes CPU I/O)
- POC uses std::fs::read for I/O; Phase 2 will integrate MTLIOCommandQueue for true I/O-compute overlap
- 7 streaming tests: large data (>64MB), small files, no matches, partitioning, empty input, case insensitive, profiling
- GpuResidentIndex simplified from rust-experiment: no mmap/GPU-direct storage, just Vec<GpuPathEntry> + optional GPU buffer cache
- to_gpu_buffer() uses newBufferWithBytes_length_options (copy) not bytesNoCopy (entries Vec may reallocate); cached after first call
- Borrow checker: to_gpu_buffer(&mut self) returns &Retained<..> tied to mutable borrow -- must snapshot entry_count/entries before call in tests
- build_from_directory skips .git, .hg, node_modules, target, __pycache__, .build, and all hidden directories (starts with '.')
- GpuPathEntry uses u32 path_len/flags/mtime and split u32 size_lo/size_hi -- different from rust-experiment's u16/u64 fields
- SharedIndexManager uses 64-byte binary header (magic GSIX, version, entry_count, root_hash, saved_at) + packed GpuPathEntry array
- Cache key = hash of canonicalized root path, index files stored at ~/.gpu-search/index/<hash>.idx
- GpuResidentIndex.from_entries() constructor needed for loading cached entries without re-statting the filesystem
- Staleness check uses Duration >= comparison (not >) so max_age=0 always triggers rebuild
- Atomic save: write to .idx.tmp then rename for crash safety

- POC end-to-end wiring: main.rs takes pattern+dir args, walks directory, runs StreamingSearchEngine, resolves GPU byte_offset to file:line:content
- StreamingMatch.byte_offset was engine-global (chunk_index * 4096 + context_start); fixed to track per-file start_chunk offset for correct file-relative offsets
- GPU miss rate ~1-7% on real source files due to 64-byte thread boundary limitation -- matches grep output within expected tolerance
- End-to-end pipeline: GpuDevice -> PsoCache (4 kernels) -> StreamingSearchEngine -> resolve_line -> grep-like stdout output
- Binary file extension filtering (metallib, air, images, archives, etc.) prevents GPU from wasting time on non-text files
- resolve_line reads file, counts newlines up to byte_offset, extracts full line content -- simple but correct for POC
- 16 source files (0.13 MB) searched in ~6ms on M4 Pro; 158/160 "fn " matches found (98.75% hit rate)

- ignore crate WalkBuilder needs git init for .gitignore parsing -- temp dirs in tests must run `git init` first
- FilesystemScanner uses ignore crate's built-in parallel walker (not rayon directly) -- WalkBuilder.build_parallel() handles thread pool
- Mutex<Vec<GpuPathEntry>> collects results from parallel walker threads; sorted by path after collection for deterministic output
- ScannerConfig: respect_gitignore, follow_symlinks, skip_hidden, max_depth, threads -- all tested
- 10 scanner tests: basic, nested, hidden skip/show, paths exist, metadata, max_depth, empty, deterministic, gitignore

- cache.rs is a thin mmap wrapper over shared_index.rs binary format -- reuses same 64B header + packed GpuPathEntry layout
- MmapIndexCache::load_mmap() validates header (magic, version, entry_count, root_hash) then casts mmap'd bytes to &[GpuPathEntry] slice -- zero-copy
- SharedIndexManager::save() writes the file, MmapIndexCache::load_mmap() reads it back via mmap -- no duplication of save logic
- cache_key() function duplicated from SharedIndexManager for standalone use; verified identical results in test
- MmapBuffer requires non-empty files so empty index files (header-only, 64 bytes) still work since 64 > 0
- 9 cache tests: save+mmap load, into_resident_index, not_found, corrupt, wrong_root_hash, get_entry, roundtrip_fidelity, cache_key_consistency, integration test

- GpuIndexLoader orchestrates cache-first pipeline: try mmap cache -> Metal buffer; fallback to scan -> build -> save -> load
- GpuLoadedIndex holds Retained<MTLBuffer>, entry_count, root path, from_cache flag, load_time, and optional MmapBuffer to keep zero-copy alive
- MmapIndexCache.into_resident_index() copies entries from mmap into Vec, then to_gpu_buffer() uploads to Metal -- not true zero-copy but still fast
- For true zero-copy GPU loading, would need to create Metal buffer from mmap at correct offset (skip 64B header) -- deferred for simplicity
- 4 gpu_loader tests: basic load+cache, real src/ scan, empty dir, cache invalidation after file add -- all pass
- Cache invalidation works via directory mtime: adding/modifying files updates dir mtime, which SharedIndexManager.is_stale() detects

- gpu-query WorkQueue at gpu-query/src/gpu/autonomous/work_queue.rs (NOT gpu-query/src/gpu/work_queue.rs as tasks.md suggests)
- SearchRequestSlot is 512 bytes (same as QueryParamsSlot): sequence_id(0) + status(4) + flags(8) + pattern_len(12) + pattern[256](16) + total_bytes(272) + max_matches(276) + file_count(280) + match_count(284) + elapsed_us(288) + error_code(292) + reserved(296)
- get_latest() scans all 3 slots for highest sequence_id with status==COMPLETE -- enables GPU to write results back into the same slot
- submit_request() returns the assigned sequence_id for request tracking

- SearchExecutor uses dedicated background thread (not Metal completion handler recursion) for re-dispatch -- more reliable than RcBlock stacking
- Thread polls for work via condvar with 10ms timeout; idle after 500ms of no work -> parks thread
- MTLSharedEvent signaling: odd values = active, even values = idle; monotonically increasing counter
- GpuResources struct with unsafe impl Send wraps all ObjC Metal objects for the dispatch thread
- GPU command buffers committed with waitUntilCompleted per search (serialized); completion handler re-dispatch deferred to Phase 3 optimization
- Pre-allocated 100K chunks (~400MB) + 10K match results per dispatch; same buffer layout as ContentSearchEngine
- 6 executor tests: lifecycle (start/submit/poll/idle/wake/stop), multi-file, empty, case-insensitive, shared event, sequential searches
- First search ~8-15ms (includes PSO warmup), subsequent searches ~0.6ms on M4 Pro

- GitignoreFilter wraps ignore::gitignore::Gitignore; from_directory() walks subdirs collecting nested .gitignore files, from_str() for testing
- is_ignored() uses matched_path_or_any_parents().is_ignore() which handles globs, negation, directory markers
- filter_paths() convenience method filters Vec<&Path> in one call
- 10 tests: basic glob, source not ignored, negation (!important.log), directory patterns (build/, target/), nested .gitignore, from_str, filter_paths, no .gitignore, comments/empty lines, root accessor

- SearchOrchestrator pipeline: walk_directory (ignore crate) -> GitignoreFilter -> BinaryDetector -> filetype filter -> filename matches -> StreamingSearchEngine GPU search -> resolve_match (byte_offset to line/content/context) -> SearchResponse
- Ranking uses std::sync::mpsc (no crossbeam-channel dependency needed for progressive delivery)
- File match ranking: path length ascending (shorter = more relevant), alphabetical tiebreak
- Content match ranking: word boundary matches first (1.0), partial matches second (0.5), path depth tiebreak
- Progressive delivery: Wave 1 (FileMatches) -> Wave 2 (ContentMatches) -> Complete (SearchResponse with stats)
- truncate_results caps at MAX_RESULTS (10K) after ranking to avoid memory blowup
- is_word_boundary_match checks both left and right boundaries (non-alphanumeric, non-underscore)
- Filename matches scored by inverse path length + exact/prefix match bonuses; sorted descending by score
- resolve_match splits content into lines, finds target line by cumulative byte offset, extracts 2 lines of context before/after
- walk_directory uses ignore crate with git_ignore=false (we apply GitignoreFilter separately for pipeline control)
- 8 orchestrator tests: basic, filetype filter, no matches, binary excluded, case insensitive, file matches, empty dir, real src/ search
- eframe 0.31.1 re-exports egui as `eframe::egui` -- must `use eframe::egui;` in app modules, NOT add egui as separate dependency
- eframe::App::update() signature: `fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame)`
- AppCreator returns Result: `Box<dyn FnOnce(&CreationContext) -> Result<Box<dyn App>, DynError>>`
- ViewportBuilder for window config: with_inner_size([720.0, 400.0]), with_decorations(false) for floating panel
- eframe::NativeOptions has viewport field (ViewportBuilder) for window configuration
- egui 0.31: HandleShape and NumericColorSpace enums do NOT implement Default -- must use explicit variants (HandleShape::Circle, NumericColorSpace::GammaByte)
- egui 0.31 Visuals: uses `corner_radius` (CornerRadius) not `rounding` (deprecated); Shadow has offset/blur/spread/color fields
- Tokyo Night theme: TEXT_PRIMARY (#C0CAF5) on BG_BASE (#1A1B26) has contrast ratio ~9.5:1 (well above WCAG AA 4.5:1 threshold)
- ACCENT_SELECTION_BG uses premultiplied alpha for selection background overlay
- SearchBar debounce: prev_query snapshot detects changes without egui response; Instant::now() + elapsed check for timer; separate simulate_input()/check_debounce() for unit testing without UI context
- SearchMode enum (Filename=1char, Content=2char) controls minimum query length gating after debounce fires
- egui TextEdit singleline with hint_text() for placeholder; horizontal layout with search icon + filter toggle button
- ResultsList uses nested ScrollArea.show_rows() for virtual scrolling -- each section (file/content) gets its own scroll area with id_salt to avoid conflicts
- Custom painting via allocate_exact_size + Painter for selection highlight (ACCENT-tinted background + left border) and query match highlighting
- Monospace font char_width approximated as font_size * 0.6 for highlight rectangle positioning
- Case-insensitive query matching in render_highlighted_text for both file paths and content lines
- ContentMatch row renders: file:line header (muted) + 1 context_before + match line (highlighted) + 1 context_after = ~80px row height
- 12 unit tests cover navigation (wrapping, cross-section), selection (file/content/line/none), truncation, and 10K virtual scroll data structures
- Keybinds: separated mapping logic (map_key_action) from egui context (process_input) for testability; ModifierState/KeyPress types enable unit testing without running egui
- egui 0.31 InputState.consume_key(Modifiers, Key) consumes key events so they aren't forwarded to text input widgets; Modifiers::COMMAND = Cmd on macOS
- process_input must check Cmd+key combos BEFORE plain key checks (Cmd+Enter before Enter) to avoid consuming the plain key first
- StatusBar: match_count, elapsed, search_root, active_filter_count; format_status() for testable string output; truncate_path() keeps tail for readability
- FilterBar with SearchFilter enum (Extension, ExcludeDir, CaseSensitive); apply_to_request() sets file_types and case_sensitive on SearchRequest; to_search_params() returns (file_types, excluded_dirs, case_sensitive) tuple
- egui 0.31 Margin::symmetric() takes i8 values (not f32); Frame::new() replaces deprecated Frame::none()
- Filter pills rendered with Frame::new().fill().stroke().corner_radius().inner_margin() + horizontal layout with dismiss (X) button
- highlight.rs (task 2.17) had compilation errors: syntect 5.3 ThemeSettings needs brackets_background, minimap_border, popup_css, phantom_css fields; RangedHighlightIterator::new() takes &mut HighlightState (not ScopeStack); returns (Style, &str, Range<usize>) triples (need .map to drop range); FromStr trait import needed for ScopeSelectors::from_str()
- syntect theme: generic "punctuation" scope rule overrides comment punctuation (`//`) because syntect classifies `//` as both `punctuation.definition.comment` and `comment.line`; removed punctuation rule since FG_DEFAULT is already the theme default foreground
- syntect 5.3: ThemeSettings implements Default, so use `..ThemeSettings::default()` instead of listing all None fields; HighlightState::new() needs Highlighter reference + initial ScopeStack
- 15 highlight tests: syntax coloring (Rust/Python/JS), query match overlay (case-insensitive, multiple matches, bold amber bg), cache management, theme validation, styled span construction
- cancel.rs: CancellationToken/CancellationHandle pair (Arc<AtomicBool>, Relaxed ordering), SearchGeneration (AtomicU64 AcqRel), SearchGenerationGuard.is_stale(), SearchSession combines both; 8 tests including cross-thread cancellation and concurrent generation increment

## Next
Task 2.22 or next available task
