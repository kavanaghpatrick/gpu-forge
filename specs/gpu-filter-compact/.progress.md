---
spec: gpu-filter-compact
basePath: specs/gpu-filter-compact
phase: tasks
task: 0/22
updated: 2026-02-20
---

# Progress: gpu-filter-compact

## Original Goal

GPU filter+compact kernel for numeric WHERE clauses â€” 10-25x over Polars on selective filters

## Completed Tasks

- [x] 1.1 Scaffold forge-filter crate

## Current Task

Awaiting next task

## Learnings

- Decoupled lookback deadlocks on Apple Silicon -- scan.metal already uses 3-pass reduce-then-scan. Decoupled Fallback (b0nes164) shows promise but adds complexity.
- Existing 5-dispatch compact pipeline achieves 42-73 GB/s (phase1_foundation.json). Fused 3-dispatch should reach 150-200 GB/s.
- Polars filter baseline measured on this machine: 2780 Mrows/s @ 16M, 4489 @ 4M, 4117 @ 1M. GPU dispatch overhead dominates below 1M elements.
- forge-primitives already has scan.metal (3-pass SIMD prefix scan), compact_scan.metal (flags+scatter), filter_bench.metal (simd_sum count). All reusable.
- PsoCache supports function constants (FnConstant::Bool/U32) -- ideal for predicate type specialization at zero runtime cost.
- Atomic scatter (unordered) is 30-40% faster than scan-based ordered compact at high selectivity -- useful for aggregation queries.
- f64 has 1/32 throughput on M4 Pro -- filter f64 columns will be ~32x slower than f32. Document this limitation.
- forge-sort `SortBuffer<T>` pattern with zero-copy StorageModeShared is the proven API pattern to follow.
- forge-sort uses sealed SortKey trait to restrict types at compile time -- FilterKey should follow same pattern.
- forge-sort exposes both buffer API (zero-copy) and convenience slice API (copy in/out) -- forge-filter needs both.
- 42 type/operator combos (6 types x 7 predicates) is the correctness test matrix; compound predicates add more.
- Output buffer ownership is an open design question -- returning new FilterResult is simplest; `filter_into()` for advanced reuse.
- Multi-column compound predicates deferred to P2 to avoid scope creep on initial release.
- FilterBuffer<T> vs SortBuffer<T> interop needs design decision -- separate types with conversion preferred.
- scan_partials with 4 elements/thread only handles 1024 partials = 4M elements. For 16M need 16 elems/thread (4096 partials). For 64M+ need hierarchical scan (2 extra dispatches).
- forge-sort inlines metal_helpers.rs (PsoCache, FnConstant, alloc_buffer) rather than depending on forge-primitives. forge-filter follows same pattern for independent crates.io publishing.
- FilterParams uses uint lo_bits/hi_bits with as_type<T> reinterpretation in Metal -- avoids template metaprogramming, single struct for all 32-bit types.
- 64-bit types need separate FilterParams64 struct (lo/hi each split into two uint32 fields) due to Metal setBytes alignment constraints.
- Predicate re-evaluation in scatter kernel is free (1 compare hidden behind memory latency) and avoids 64MB flags buffer at 16M elements.
- Single encoder + multiple dispatchThreadgroups() gives implicit memory barriers between dispatches -- proven in forge-sort's 4-dispatch pipeline.
- At 50% selectivity, realistic speedup is ~8x over Polars (not 10x) due to 2x input read. 10x+ achieved at selectivities below ~25%, which is the typical SQL WHERE clause scenario.
- SIMD-aggregated atomics for unordered mode: 1 atomic per 32 threads = near-zero contention even at 16M elements.
- Function constant index allocation: 0=PRED_TYPE, 1=IS_64BIT, 2=OUTPUT_IDX, 3=OUTPUT_VALS. Pre-compile 15 PSOs at init (7 predicates x 2 kernels + scan).
- Cargo.toml [[bench]] section requires the bench file to exist even for `cargo build` -- created stub benches/filter_benchmark.rs.

## Interview Responses

### Requirements Interview (from requirements.md)
- Primary users: Published crate users (external Rust developers via crates.io)
- Priority tradeoffs: Prioritize API completeness (full predicate set and compound filters)
- Success criteria: 10x+ over Polars on numeric filters at 16M+ rows with measured benchmarks

## Blockers

- None currently

## Next

Task 1.2: Implement FilterKey trait, Predicate enum, FilterParams, FilterError

## Task Planning Insights

- 22 tasks total: 7 POC, 8 core features, 4 testing, 5 polish+publish, 3 PR lifecycle
- Critical dependency: hierarchical scan must be implemented before 64M test (task 3.3). scan_partials handles max 4096 partials = 16.7M elements (32-bit). 64M needs 15625 tiles = requires L1/L2 hierarchical scan (5 dispatches instead of 3).
- Compound predicates (task 2.7) are the most complex single task -- multi-pass mask composition for general AND/OR, with BETWEEN optimization for common Ge+Le pattern.
- forge-sort metal_helpers.rs can be copied verbatim -- PsoCache, FnConstant, alloc_buffer, init_device_and_queue are identical.
- Quality checkpoints at tasks 1.7, 2.4, 2.8, 3.4, 4.3 catch regressions early.
- POC (tasks 1.1-1.6) proves the 3-dispatch pipeline end-to-end for u32 Gt only. All other types/predicates deferred to Phase 2.
- workspace Cargo.toml at `metal-forge-compute/Cargo.toml` currently has 3 members -- adding forge-filter as 4th member.
- Benchmark task 4.4 may reveal 10x is only achievable at <25% selectivity -- design already accounts for this (8x at 50% is acceptable, 10x+ at typical SQL WHERE selectivity).
