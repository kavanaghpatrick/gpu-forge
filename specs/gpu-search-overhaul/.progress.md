# gpu-search-overhaul

## Original Goal

Comprehensive gpu-search profiling, accuracy, and performance overhaul. 5 issues from foreman spec analysis (see gpu-search/ai/tasks/spec/PM.md, TECH.md, QA.md, UX.md):

1. **SEARCH ACCURACY BUG (P0)**: GPU content_search_kernel returns correct byte matches but resolve_match() in orchestrator.rs maps byte_offset to wrong file when multi-file GPU batches span chunks. Fix: add CPU verification layer using memchr::memmem.

2. **SLOW TIME-TO-FIRST-RESULT**: Benchmark data shows GPU compute is <50ms total but I/O takes 33s to walk 700K files from root /. Triple I/O tax. Fix: wire existing MmapIndexCache + SharedIndexManager into orchestrator. Use mmap+bytesNoCopy for zero-copy GPU access (KB #1288: 16KB page alignment, KB #248: 0.0004ms transfer).

3. **FILESYSTEM INDEX**: Existing GSIX binary format in src/index/ is complete but unwired. Wire notify v7 + FSEvents. Channel-swap pattern.

4. **PIPELINE PROFILER**: Add Instant-based PipelineProfile with per-stage timing. P50/P95/P99 metrics. Criterion regression detection.

5. **TEST GAPS**: No test verifies resolve_match() accuracy (GAP-1). No multi-file batch chunk mapping test (GAP-2). Add grep oracle tests.

Additional strategies from KB:
- CPU/GPU hybrid dispatch: route files <64KB to CPU memchr, larger to GPU (KB #1134)
- TLB shootdown mitigation via fast page recycling (KB #595: 28% improvement)
- Apple Silicon unified memory eliminates GPUDirect Storage need (KB #1338)

## Completed Tasks
- [x] 1.1 Add memchr CPU verification module - b170e7f
- [x] 1.2 Add accuracy test: assert every returned line contains pattern
- [x] 1.3 Fix byte_offset mapping in collect_results()
- [x] 1.4 Add multi-file batch chunk mapping test
- [x] 1.5 Wire CPU verification into dispatch_gpu_batch
- [x] 1.6 Add resolve_match() unit tests
- [x] 1.7 POC Checkpoint -- zero false positives verified
- [x] 2.1 Implement PipelineProfile struct
- [x] 2.2 Instrument orchestrator with per-stage timing
- [x] 2.3 Wire MmapIndexCache into orchestrator search path
- [x] 2.4 Add notify v7 + debouncer dependencies

## Current Phase
execution (Phase 2 in progress)

## Reality Check (BEFORE)

**Goal type**: Fix (P0 accuracy bug) + Add (index, profiler, tests)
**Reproduction**: False positives observed when searching from root `/` -- GPU byte_offset maps to wrong file in multi-file batches.

## Learnings

- P0 bug is NOT in the GPU kernel -- it's in the CPU-side byte_offset interpretation chain across 3 files (content.rs `collect_results()`, streaming.rs `search_files_with_profile()`, orchestrator.rs `resolve_match()`)
- `context_start` in GpuMatchResult has dual meaning: GPU writes `offset_in_chunk + line_start_in_64B_window`, but `line_start` only counts newlines within the local 64-byte thread window, not from chunk start. For matches >64B into a chunk, this produces incorrect line-start positions.
- The `resolve_match()` safety net (`find(pattern)` returning None on mismatch) already catches most false positives, but also discards valid matches whose byte offsets are slightly wrong.
- GSIX index infrastructure is complete (cache.rs, scanner.rs, shared_index.rs, gpu_index.rs, gpu_loader.rs) but the orchestrator never calls any of it -- the index is fully unwired.
- `turbo_search.metal` already implements deferred line counting (GPU records byte offsets only, CPU extracts lines) -- this should be the default path, per KB #1320/#1322.
- memchr crate is already in Cargo.toml -- CPU verification layer has zero new dependencies.
- Streaming pipeline (streaming.rs) is quad-buffered in structure but sequential in I/O (POC mode). True MTLIOCommandQueue overlap is Phase 2.
- Foreman analysis (PM.md, TECH.md, QA.md, UX.md) was thorough -- 4 files totaling ~108KB of analysis provided the complete root cause chain, fix strategy, test gaps, and architecture plan.
- Multi-file batch byte_offset test: build_file() helper places "ALPHA" at exact byte offsets by pre-filling with underscores then stamping the pattern. Newline placement avoids protected pattern ranges. All 5 matches (across 4 files of 100B, 200B, 8KB, 16KB) correctly attributed with zero false positives.
- The `ContentMatch` struct in content.rs uses `byte_offset = chunk_index * 4096 + context_start` -- the fix is to use `context_start + column` to get the actual match position instead of the (incorrect) line start.
- verify.rs: `memchr::memmem::Finder::find_iter` returns non-overlapping matches (important for patterns like "aa" in "aaaa" -- returns 0,2 not 0,1,2).
- VerifyMode::from_env() reads GPU_SEARCH_VERIFY env var -- "full", "sample", or default "off".
- Accuracy tests pass initially (161 matches, 0 false positives, 100% accuracy) -- the P0 bug may only manifest with larger multi-file batches or specific byte_offset patterns from root `/` searches. The tests are designed to catch it when triggered.
- generate_corpus_file() helper inserts patterns at evenly spaced positions within filler text using underscore characters to avoid accidental pattern matches.
- types.rs ContentMatch has: path (PathBuf), line_number (u32), line_content (String), context_before/after (Vec<String>), match_range (Range<usize>).
- byte_offset fix: `context_start + column` gives the actual match position. `context_start` = offset_in_chunk + line_start_in_window, `column` = local_pos - line_start, so sum = offset_in_chunk + local_pos = match position in chunk. The proptest `prop_no_false_positives` also needed updating since it was computing `byte_offset + column` which now double-counts column.
- CPU verification wired into both `search()` (blocking) and `dispatch_gpu_batch()` (streaming) paths. Groups GPU results by file, reads each file, calls cpu_verify_matches(). In Full mode, panics on false positives so tests fail fast. Verified: all 3 accuracy tests pass with GPU_SEARCH_VERIFY=full, 0 false positives across 161 matches.
- resolve_match() is a private free function accessible from inline `mod tests` via `use super::*`. No visibility change needed. Tests use tempfile for isolated file creation. The function correctly handles: exact line+column resolution, out-of-bounds rejection, pattern-not-on-line rejection, multi-chunk files, last line without trailing newline, empty files, and case-insensitive matching.
- Phase 1 POC complete: 433 tests pass (276 unit + 157 integration/accuracy/proptest), Metal shader validation enabled, 161 accuracy matches with 0 false positives (100% accuracy). GPU kernel misses are documented (boundary-crossing) but zero false positives confirmed.
- PipelineProfile struct: 7 timing fields (walk/filter/batch/gpu_load/gpu_dispatch/resolve/total + ttfr), 9 counters (files_walked/filtered/searched, bytes_searched, gpu_dispatches, matches_raw/resolved/rejected). Display impl shows stage breakdown with derived metrics (throughput, selectivity, rejection rate). Modeled as superset of StreamingProfile.
- Pipeline instrumentation: `search()` (blocking) uses `search_files_with_profile()` directly and merges StreamingProfile fields into PipelineProfile. `search_streaming()` uses `dispatch_gpu_batch_profiled()` per batch and accumulates across batches. TTFR tracked via flag on first ContentMatches send. StreamingProfile.io_us -> gpu_load_us, .search_us -> gpu_dispatch_us, .partition_us -> batch_us.
- GSIX index wiring: `try_index_producer()` is a static method on SearchOrchestrator that checks SharedIndexManager for a fresh index (<1hr), loads via MmapIndexCache::load_mmap() for zero-copy, iterates entries through the crossbeam channel with same binary/filetype filters as walk_and_filter. Falls back gracefully if index missing/stale/corrupt. Producer thread becomes Option<JoinHandle> to handle both paths.

## Next
Task 2.5: Implement IndexWatcher with FSEvents
