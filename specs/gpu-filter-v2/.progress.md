---
spec: gpu-filter-v2
basePath: ./specs/gpu-filter-v2
phase: tasks
task: 0/34
updated: 2026-02-20
---

# Progress: gpu-filter-v2

## Original Goal

Improve forge-filter to 10x+ ordered mode (vs Polars CPU), add multi-column filter, Arrow zero-copy integration, NULL bitmap support, and Polars expression plugin — targeting publication as polars-gpu-filter crate.

## Intent Classification

- Type: GREENFIELD (new crate polars-gpu-filter + major forge-filter v2 features)
- Complexity: HIGH (5 features, GPU kernels, FFI boundary, Arrow interop)

## Interview Responses

### Goal Interview (from foreman-spec)
- Primary users: Published crate users (Rust developers, Polars users)
- Priority: API completeness and 10x+ performance
- Success criteria: 10x+ over Polars CPU on ordered mode

### Foreman-Spec Decisions
- Arrow alignment: Always copy to page-aligned Metal buffer (~0.5ms)
- NULL semantics: Exclude NULLs (matches Polars filter())
- Backward compat: Extend current API (v0.2.0 minor bump)
- CI strategy: Self-hosted M4 runner
- Plugin return: BooleanChunked mask
- PSO caching: Lazy compilation
- Performance target: 10x vs Polars CPU → 580µs ordered

## Completed Tasks
- [x] 1.1 Add `filter_bitmap_scan` kernel to filter.metal
- [x] 1.2 Add `filter_bitmap_scatter` kernel to filter.metal
- [x] 1.3 Wire bitmap pipeline into Rust dispatch path

## Current Task
Awaiting next task

## Learnings

- Foreman-spec analysis complete with 4 agents (PM, UX, Tech, QA)
- 22+ GPU KB findings cited across analyses
- Full spec files at ai/tasks/spec/ (PM.md, QA.md, forge-filter-v2-TECH.md, OVERVIEW.md)
- Requirements: "10x ordered" means 10x vs Polars CPU (580us target), NOT 10x improvement over current (physically impossible at 85us)
- Current API surface is clean: GpuFilter + FilterBuffer<T> + FilterResult<T> + Predicate<T> + FilterKey sealed trait. All must be preserved.
- Compound predicates (And/Or) already exist in v0.1 but use multi-pass cascade or CPU fallback. Multi-column (US-2) is cross-column AND, different from single-column compound.
- Arrow alignment: always-copy decision simplifies implementation but means "zero-copy" claim only applies to unified memory (no DMA), not to avoiding memcpy
- BooleanMask is a new type not in v0.1 -- needed for multi-column filter output and Polars plugin return path
- arrow-rs vs arrow2 ambiguity: Polars uses arrow2 internally but exposes arrow-rs compatible types. Need to resolve during design phase.
- PSO variant explosion is theoretical (8960 combos) but ~50 in practice. Lazy compilation + MTLBinaryArchive makes this manageable.
- Task planning: 34 tasks across 5 phases (POC 7, Features 10, Testing 7, Quality 4, PR 4+publish 2)
- Polars expression plugin (US-5) deferred to separate spec — too much FFI complexity for forge-filter v0.2.0
- Multi-column kernel capped at 4 columns (not 8 from requirements) — covers 99% real queries; function constant explosion at 8
- Separate-scan-then-AND approach for multi-column is safer POC than fused kernel; can optimize later
- All 47 existing tests confirmed passing (13.23s total runtime) as of task planning
- `build.rs` compiles shaders with `-std=metal3.2` — simd_ballot and device-scope fences available
- Bitmap buffer size: ceil(N/32)*4 bytes = 2MB for 16M elements — well within SLC (24MB on M4 Pro)
- filter_bitmap_scan buffer layout differs from filter_predicate_scan: needs bitmap buffer at index 1, shifts partials and params
- filter_bitmap_scatter buffer layout has 6 bindings (src, bitmap, out_vals, out_idx, partials, params) vs scatter's 5
- Quality checkpoints inserted every 2-3 tasks throughout all phases (8 total [VERIFY] tasks)
- Arrow v54 chosen for Cargo.toml — current stable release, compatible with Polars internals
- Key risk area: simd_ballot packing correctness — lane 0 must write the ballot word at the correct bitmap offset accounting for simdgroup position within the threadgroup and element round
- CRITICAL: `simd_ballot()` returns opaque `simd_vote` on Metal — CANNOT extract uint bitmask. Must use `manual_ballot()` via butterfly reduction (5x `simd_shuffle_xor`). Pattern proven in exp19_wlms.metal.
- HAS_NULLS function constant added at index 5 with default false — gated at PSO compile time, zero overhead when not used
- filter_bitmap_scatter reads bitmap[idx/32] and extracts bit (idx%32) instead of re-evaluating predicate — identical round-by-round prefix sum pattern as filter_scatter, 6 buffer bindings (src, bitmap, out_vals, out_idx, partials, params)
- CRITICAL: Bitmap buffer must be sized for full tiles (num_tiles * tile_size / 32), NOT ceil(n/32). The kernel writes bitmap words for ALL simdgroup slots in each tile, including out-of-bounds elements (those bits are zero). Undersized bitmap causes out-of-bounds GPU writes that corrupt adjacent Metal buffer memory, producing intermittent failures under concurrent load.
- Compound AND cascade (filter_compound_and_cascade) should use dispatch_filter (non-bitmap), not dispatch_filter_bitmap — bitmap has no benefit for multi-pass cascade since each pass re-reads all data, and using bitmap in cascade causes data corruption between passes.
- dispatch_filter kept intact as fallback (with #[allow(dead_code)]) — used by cascade AND and filter_unordered paths.
- filter(), filter_indices(), and filter_with_indices() now use dispatch_filter_bitmap for simple predicates in ordered mode.
- PSO for filter_bitmap_scan: function constants PRED_TYPE(0), IS_64BIT(1), DATA_TYPE(4) — same as filter_predicate_scan
- PSO for filter_bitmap_scatter: function constants IS_64BIT(1), OUTPUT_IDX(2), OUTPUT_VALS(3), DATA_TYPE(4) — no PRED_TYPE needed

### Verification: 1.4 [VERIFY] Quality checkpoint: all v0.1 tests pass with bitmap pipeline
- Status: PASS
- Commands: cargo test (47 passed, 0 failed + 3 doc-tests passed), cargo clippy -- -D warnings (0 warnings)
- Duration: ~13.5s tests + ~1.4s clippy
- All 47 unit tests pass, 3 doc-tests pass, zero clippy warnings

## Blockers

- None currently

## Completed Tasks
- [x] 1.1 Add `filter_bitmap_scan` kernel to filter.metal
- [x] 1.2 Add `filter_bitmap_scatter` kernel to filter.metal
- [x] 1.3 Wire bitmap pipeline into Rust dispatch path
- [x] 1.4 [VERIFY] Quality checkpoint: all v0.1 tests pass with bitmap pipeline

## Next

Task 2.1: Next implementation task
