// MetalCompute.swift â€” Metal pipeline wrapper for {{KERNEL_NAME}}
// Generated by gpu-forge

import Metal
import Foundation

/// Wraps Metal compute pipeline creation and dispatch for the {{KERNEL_NAME}} kernel.
///
/// Usage:
/// ```swift
/// let compute = try MetalCompute()
/// let result = try compute.run(input: inputBuffer)
/// ```
final class MetalCompute {

    // MARK: - Properties

    let device: MTLDevice
    let commandQueue: MTLCommandQueue
    let pipelineState: MTLComputePipelineState

    /// Number of buffers this kernel expects (input + output)
    static let bufferCount = {{BUFFER_COUNT}}

    // MARK: - Initialization

    /// Creates a Metal compute pipeline for the `{{KERNEL_NAME}}` kernel.
    ///
    /// - Throws: If Metal device, library, or pipeline creation fails.
    init() throws {
        guard let device = MTLCreateSystemDefaultDevice() else {
            throw MetalComputeError.noDevice
        }
        self.device = device

        guard let commandQueue = device.makeCommandQueue() else {
            throw MetalComputeError.noCommandQueue
        }
        self.commandQueue = commandQueue

        guard let library = device.makeDefaultLibrary() else {
            throw MetalComputeError.noLibrary
        }

        guard let function = library.makeFunction(name: "{{KERNEL_NAME}}") else {
            throw MetalComputeError.noFunction("{{KERNEL_NAME}}")
        }

        self.pipelineState = try device.makeComputePipelineState(function: function)
    }

    // MARK: - Buffer Creation

    /// Creates a shared-mode buffer suitable for CPU/GPU data exchange.
    ///
    /// - Parameter size: Buffer size in bytes.
    /// - Returns: A new Metal buffer.
    func makeBuffer(size: Int) throws -> MTLBuffer {
        guard let buffer = device.makeBuffer(length: size, options: .storageModeShared) else {
            throw MetalComputeError.bufferAllocation(size)
        }
        return buffer
    }

    // MARK: - Dispatch

    /// Encodes and dispatches the {{KERNEL_NAME}} compute kernel.
    ///
    /// - Parameters:
    ///   - buffers: Array of Metal buffers to bind (must have exactly `bufferCount` elements).
    ///   - elementCount: Number of elements to process.
    /// - Returns: Elapsed time in milliseconds.
    @discardableResult
    func run(buffers: [MTLBuffer], elementCount: Int) throws -> Double {
        guard buffers.count == Self.bufferCount else {
            throw MetalComputeError.wrongBufferCount(
                expected: Self.bufferCount, got: buffers.count
            )
        }

        guard let commandBuffer = commandQueue.makeCommandBuffer() else {
            throw MetalComputeError.noCommandBuffer
        }

        guard let encoder = commandBuffer.makeComputeCommandEncoder() else {
            throw MetalComputeError.noEncoder
        }

        // Bind pipeline and buffers
        encoder.setComputePipelineState(pipelineState)
        for (index, buffer) in buffers.enumerated() {
            encoder.setBuffer(buffer, offset: 0, index: index)
        }

        // Threadgroup sizing: multiple of 32 (Apple Silicon SIMD width)
        let maxThreads = pipelineState.maxTotalThreadsPerThreadgroup
        let threadsPerGroup = min(maxThreads, 256)
        let threadgroupSize = MTLSize(width: threadsPerGroup, height: 1, depth: 1)
        let gridSize = MTLSize(width: elementCount, height: 1, depth: 1)

        encoder.dispatchThreads(gridSize, threadsPerThreadgroup: threadgroupSize)
        encoder.endEncoding()

        // Commit and measure
        let startTime = CFAbsoluteTimeGetCurrent()
        commandBuffer.commit()
        commandBuffer.waitUntilCompleted()
        let elapsed = (CFAbsoluteTimeGetCurrent() - startTime) * 1000.0

        if let error = commandBuffer.error {
            throw MetalComputeError.executionFailed(error)
        }

        return elapsed
    }
}

// MARK: - Errors

enum MetalComputeError: Error, CustomStringConvertible {
    case noDevice
    case noCommandQueue
    case noLibrary
    case noFunction(String)
    case noCommandBuffer
    case noEncoder
    case bufferAllocation(Int)
    case wrongBufferCount(expected: Int, got: Int)
    case executionFailed(Error)

    var description: String {
        switch self {
        case .noDevice:
            return "Metal is not supported on this device"
        case .noCommandQueue:
            return "Failed to create Metal command queue"
        case .noLibrary:
            return "Failed to load default Metal library"
        case .noFunction(let name):
            return "Kernel function '\(name)' not found in Metal library"
        case .noCommandBuffer:
            return "Failed to create command buffer"
        case .noEncoder:
            return "Failed to create compute command encoder"
        case .bufferAllocation(let size):
            return "Failed to allocate Metal buffer of \(size) bytes"
        case .wrongBufferCount(let expected, let got):
            return "Expected \(expected) buffers, got \(got)"
        case .executionFailed(let error):
            return "Kernel execution failed: \(error)"
        }
    }
}
