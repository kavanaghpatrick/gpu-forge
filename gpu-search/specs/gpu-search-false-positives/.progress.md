# Progress: gpu-search-false-positives

## Reality Check (BEFORE)

**Goal type**: Fix
**Reproduction command**: `cargo test --lib -- --test-threads=1`
**Exit code**: 0 (556 tests pass)
**Error output**: None -- existing tests pass. The false positives are a runtime bug observed in the UI when searching for "kolbey" (returns 9 matches for "Patrick Kavanagh" files on first search, 0 on second identical search).

**Key errors to resolve**:
- Error 1: `ContentSearchEngine::reset()` only resets counters, does NOT zero GPU buffer data. Stale data from previous searches persists in `chunks_buffer`.
- Error 2: Rapid query changes may cause race conditions where old GPU dispatches produce results attributed to the new query.
- Error 3: `byte_offset` calculation in streaming.rs may produce incorrect file-relative offsets, causing `resolve_match()` to map to wrong lines.

**Observed symptom**: Searching "kolbey" returns 9 false positive matches for "Patrick Kavanagh" files. Repeating the same search returns 0 matches (correct). This inconsistency indicates stale GPU buffer data from a previous query.

## Learnings

- `ContentSearchEngine` pre-allocates GPU buffers once and reuses them (no per-search allocation). This is efficient but means stale data persists.
- `reset()` at line 295 of content.rs only sets `current_chunk_count = 0`, `total_data_bytes = 0`, `file_count = 0`. The actual `chunks_buffer` and `metadata_buffer` retain data from the previous search.
- GPU kernel's `content_search_kernel` uses `params.chunk_count` and `params.total_bytes` to bound its work, but `total_bytes = current_chunk_count * CHUNK_SIZE` which is the padded size -- if fewer files load in the new search, threads processing stale data beyond the new boundary could still read old content.
- Actually, `total_bytes` IS set correctly from `current_chunk_count * CHUNK_SIZE` in `load_content()` (line 289). But the `search()` method dispatches `total_data_bytes / BYTES_PER_THREAD` threads. If `total_data_bytes` reflects only new data, the kernel should NOT read stale regions. The bug may instead be in streaming.rs sub-batching where `search_engine.reset()` is called between sub-batches but the kernel still has access to the full buffer.
- The more likely root cause: `match_count_buffer` is set to 0 at the start of `search()` (line 321), so stale match data is properly bounded. But the `metadata_buffer` retains old ChunkMetadata entries. If the kernel reads a stale metadata entry (with a valid `file_index` from a previous search), the match would reference a wrong file.
- Key insight: the `chunk_idx` computed from `byte_base / CHUNK_SIZE` in the kernel could reference a stale `ChunkMetadata` entry if `params.chunk_count` is not enforced strictly. Line 34 of the kernel does `if (chunk_idx >= params.chunk_count) return;` which should catch this. But there's still the zero-padded region within the last valid chunk -- if old data is in the padding region and the new pattern happens to match it, you get a false positive with a valid `file_index` and `chunk_idx`.
- CPU verification via `resolve_match()` should catch these false positives (line 1351-1354: pattern.find in the resolved line). The fact that they appear in the UI suggests the verification path might not reject all stale matches.
- Existing test infrastructure: 556 unit tests, integration tests in `tests/`. No tests specifically for rapid query changes or stale buffer detection.
